<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Taylor&#39;s Learning Diary</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://upeng.github.io/"/>
  <updated>2022-11-08T04:27:37.939Z</updated>
  <id>https://upeng.github.io/</id>
  
  <author>
    <name>Tayloryu【yupeng0906@gmail.com】</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python日期格式转换总结</title>
    <link href="https://upeng.github.io/2022/11/07/python%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/"/>
    <id>https://upeng.github.io/2022/11/07/python日期格式转换/</id>
    <published>2022-11-07T04:25:14.000Z</published>
    <updated>2022-11-08T04:27:37.939Z</updated>
    
    <content type="html"><![CDATA[<p>Q：问什么做这个整理？</p><p>A：在python项目开发过程中，经常遇到日期时间转换的操作，和php仅两个简单的转换函数不同，python的时间日期库函数较多，语义化不是很清晰，需要对datetime或time库函数非常熟悉才能熟练运用，而且网上随便搜一搜，得到的都是各种案例，没有一种通用的使用说明文档，导致每次都要重复search，效率很低，于是结合部分网友总结及对python时间日期库的查阅，总结了以下相对通用的方法，简单易记，减少浪费过多时间在这上面。</p><h1 id="日期转换常见场景"><a href="#日期转换常见场景" class="headerlink" title="日期转换常见场景"></a>日期转换常见场景</h1><ul><li>timestamp to string</li><li>string to timestamp</li></ul><h1 id="datetime转换场景"><a href="#datetime转换场景" class="headerlink" title="datetime转换场景"></a>datetime转换场景</h1><ul><li>timestamp to datetime struct</li><li>string to datetime struct</li><li>datetime struct to timestamp</li><li>datetime struct to string</li></ul><h1 id="通用转换流程及方法"><a href="#通用转换流程及方法" class="headerlink" title="通用转换流程及方法"></a>通用转换流程及方法</h1><h3 id="1-timestamp-gt-datetime-time-struct-gt-string"><a href="#1-timestamp-gt-datetime-time-struct-gt-string" class="headerlink" title="1. timestamp -&gt; datetime/time struct -&gt; string"></a>1. timestamp -&gt; datetime/time struct -&gt; string</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1667555103 </span>-&gt; datetime/time struct -&gt; <span class="number">2022</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">45</span>:<span class="number">03</span> | <span class="number">20221104</span> | <span class="number">2022</span>/<span class="number">11</span>/<span class="number">04</span> 等format</span><br></pre></td></tr></table></figure><blockquote><p>方法1 datetime组件</p><ul><li>datetime_struct = datetime.datetime.utcfromtimestamp(1667555103)</li><li>string = datetime_struct.strftime(“%Y-%m-%d %H:%M:%S”)</li></ul></blockquote><blockquote><p>方法2 time组件</p><ul><li>time_struct = time.localtime(1667555103)</li><li>string = time.strftime(“%Y-%m-%d %H:%M:%S”, time_struct)</li></ul></blockquote><h3 id="2-string-gt-datetime-time-struct-gt-timestamp"><a href="#2-string-gt-datetime-time-struct-gt-timestamp" class="headerlink" title="2. string -&gt; datetime/time struct -&gt; timestamp"></a>2. string -&gt; datetime/time struct -&gt; timestamp</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span><span class="string">:45:03</span> <span class="string">|</span> <span class="number">20221104</span> <span class="string">|</span> <span class="number">2022</span><span class="string">/11/04</span> <span class="string">等format</span> <span class="string">-&gt;</span> <span class="string">datetime/time</span> <span class="string">struct</span> <span class="string">-&gt;</span> <span class="number">1667555103</span></span><br></pre></td></tr></table></figure><blockquote><p>方法1 datetime组件</p><ul><li>datetime_struct = datetime.datetime.strptime(string, “%Y-%m-%d %H:%M:%S”)</li><li>stamp = datetime_struct.timestamp()</li></ul></blockquote><blockquote><p>方法2 time组件</p><ul><li>datetime_struct = datetime.datetime.strptime(string, “%Y-%m-%d %H:%M:%S”)</li><li>time.mktime(datetime_struct.timetuple())</li></ul></blockquote><h1 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h1><a id="more"></a><ul><li>昨天此刻，向前/后退n天。 =&gt; 时间戳、指定格式</li><li>昨天12:00，向前/后退n天。 =&gt; 时间戳、指定格式</li></ul><blockquote><p>to 字符串string<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datetime_struct = datetime.datetme.now() + datetime.timedelta(days=-<span class="number">1</span>)</span><br><span class="line">string = datetime_struct.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">string = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, datetime_struct.timetuple())</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>to 时间戳stamp<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datetime_struct</span> = datetime.datetme.now() + datetime.timedelta(days=-<span class="number">1</span>)</span><br><span class="line"><span class="attr">stamp</span> = datetime_struct.timestamp()</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Q：问什么做这个整理？&lt;/p&gt;
&lt;p&gt;A：在python项目开发过程中，经常遇到日期时间转换的操作，和php仅两个简单的转换函数不同，python的时间日期库函数较多，语义化不是很清晰，需要对datetime或time库函数非常熟悉才能熟练运用，而且网上随便搜一搜，得到的都是各种案例，没有一种通用的使用说明文档，导致每次都要重复search，效率很低，于是结合部分网友总结及对python时间日期库的查阅，总结了以下相对通用的方法，简单易记，减少浪费过多时间在这上面。&lt;/p&gt;
&lt;h1 id=&quot;日期转换常见场景&quot;&gt;&lt;a href=&quot;#日期转换常见场景&quot; class=&quot;headerlink&quot; title=&quot;日期转换常见场景&quot;&gt;&lt;/a&gt;日期转换常见场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;timestamp to string&lt;/li&gt;
&lt;li&gt;string to timestamp&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;datetime转换场景&quot;&gt;&lt;a href=&quot;#datetime转换场景&quot; class=&quot;headerlink&quot; title=&quot;datetime转换场景&quot;&gt;&lt;/a&gt;datetime转换场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;timestamp to datetime struct&lt;/li&gt;
&lt;li&gt;string to datetime struct&lt;/li&gt;
&lt;li&gt;datetime struct to timestamp&lt;/li&gt;
&lt;li&gt;datetime struct to string&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;通用转换流程及方法&quot;&gt;&lt;a href=&quot;#通用转换流程及方法&quot; class=&quot;headerlink&quot; title=&quot;通用转换流程及方法&quot;&gt;&lt;/a&gt;通用转换流程及方法&lt;/h1&gt;&lt;h3 id=&quot;1-timestamp-gt-datetime-time-struct-gt-string&quot;&gt;&lt;a href=&quot;#1-timestamp-gt-datetime-time-struct-gt-string&quot; class=&quot;headerlink&quot; title=&quot;1. timestamp -&amp;gt; datetime/time struct -&amp;gt; string&quot;&gt;&lt;/a&gt;1. timestamp -&amp;gt; datetime/time struct -&amp;gt; string&lt;/h3&gt;&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;1667555103 &lt;/span&gt;-&amp;gt; datetime/time struct -&amp;gt; &lt;span class=&quot;number&quot;&gt;2022&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;03&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;20221104&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;2022&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt; 等format&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;方法1 datetime组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;datetime_struct = datetime.datetime.utcfromtimestamp(1667555103)&lt;/li&gt;
&lt;li&gt;string = datetime_struct.strftime(“%Y-%m-%d %H:%M:%S”)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;方法2 time组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time_struct = time.localtime(1667555103)&lt;/li&gt;
&lt;li&gt;string = time.strftime(“%Y-%m-%d %H:%M:%S”, time_struct)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-string-gt-datetime-time-struct-gt-timestamp&quot;&gt;&lt;a href=&quot;#2-string-gt-datetime-time-struct-gt-timestamp&quot; class=&quot;headerlink&quot; title=&quot;2. string -&amp;gt; datetime/time struct -&amp;gt; timestamp&quot;&gt;&lt;/a&gt;2. string -&amp;gt; datetime/time struct -&amp;gt; timestamp&lt;/h3&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2022&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-11&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-04&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;:45:03&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20221104&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2022&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;/11/04&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;等format&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;datetime/time&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1667555103&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;方法1 datetime组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;datetime_struct = datetime.datetime.strptime(string, “%Y-%m-%d %H:%M:%S”)&lt;/li&gt;
&lt;li&gt;stamp = datetime_struct.timestamp()&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;方法2 time组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;datetime_struct = datetime.datetime.strptime(string, “%Y-%m-%d %H:%M:%S”)&lt;/li&gt;
&lt;li&gt;time.mktime(datetime_struct.timetuple())&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;具体案例&quot;&gt;&lt;a href=&quot;#具体案例&quot; class=&quot;headerlink&quot; title=&quot;具体案例&quot;&gt;&lt;/a&gt;具体案例&lt;/h1&gt;
    
    </summary>
    
      <category term="Python" scheme="https://upeng.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://upeng.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关于Guzzle http的使用总结</title>
    <link href="https://upeng.github.io/2018/04/21/guzzle-http/"/>
    <id>https://upeng.github.io/2018/04/21/guzzle-http/</id>
    <published>2018-04-21T04:02:20.000Z</published>
    <updated>2022-11-08T04:54:20.226Z</updated>
    
    <content type="html"><![CDATA[<p>What is the difference between form data and request payload?</p><p>if a request (typically POST) has Content-type header set to application/x-www-form-urlencoded the body is expected to be in the form of a standard querystring with url-encoded key=value pairs joined by &amp;. Form data section then shows the key-value parameters (when viewed parsed). This way was much more common in past because it is a default for HTML forms. other cases are shown in Request payload section (and nowadays parsed for readability as well for common formats like JSON).</p><p>Form Data 和 Request Payload 区别</p><p>如果请求头里设置<code>Content-Type: application/x-www-form-urlencoded</code>，那么这个请求被认为是表单请求，参数出现在<code>Form Data</code>里，格式为<code>key=value&amp;key=value&amp;key=value...</code>原生的<code>AJAX</code>请求头里设置<code>Content-Type:application/json</code>，或者使用默认的请求头<code>Content-Type:text/plain</code>;参数会显示在<code>Request payload</code>块里提交。</p><a id="more"></a><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="1-创建客户端"><a href="#1-创建客户端" class="headerlink" title="1. 创建客户端"></a>1. 创建客户端</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> GuzzleHttp\<span class="keyword">Client</span>;</span><br><span class="line"></span><br><span class="line">$client = new Client([</span><br><span class="line">    // Base URI is used <span class="keyword">with</span> <span class="keyword">relative</span> requests</span><br><span class="line">    <span class="string">'base_uri'</span> =&gt; <span class="string">'http://api.com'</span>,</span><br><span class="line">    // You can <span class="keyword">set</span> <span class="keyword">any</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">default</span> request options.</span><br><span class="line">    <span class="string">'timeout'</span>  =&gt; <span class="number">2.0</span>,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><blockquote><p>关于base_uri<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a client with a base URI</span></span><br><span class="line">$client = <span class="keyword">new</span> GuzzleHttp\Client([<span class="string">'base_uri'</span> =&gt; <span class="string">'https://foo.com/api/'</span>]);</span><br><span class="line"><span class="comment">// Send a request to https://foo.com/api/test</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'GET'</span>, <span class="string">'test'</span>);</span><br><span class="line"><span class="comment">// Send a request to https://foo.com/root</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'GET'</span>, <span class="string">'/root'</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2. 发送请求"></a>2. 发送请求</h2><blockquote><p>GET请求<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//style1</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'GET'</span>, <span class="string">'http://api.com/get?foo=bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//style2</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'GET'</span>, <span class="string">'http://api.com/get'</span>, [<span class="string">'query'</span> =&gt; <span class="string">'foo=bar'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//style3</span></span><br><span class="line"><span class="comment">//提供的数组参数将会使用PHP的 http_build_query</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'GET'</span>, <span class="string">'http://api.com/get'</span>, [</span><br><span class="line">    <span class="string">'query'</span> =&gt; [<span class="string">'foo'</span> =&gt; <span class="string">'bar'</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>POST请求<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//style1  content-type:application/x-www-form-urlencoded</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'POST'</span>, <span class="string">'http://api.com/post'</span>, [</span><br><span class="line">    <span class="string">'form_params'</span> =&gt; [<span class="string">'foo'</span> =&gt; <span class="string">'bar'</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">//style2  content-type:application/json</span></span><br><span class="line">$response = $client-&gt;request(<span class="string">'POST'</span>, <span class="string">'http://api.com/post'</span>, [</span><br><span class="line">    <span class="string">'json'</span> =&gt; [<span class="string">'foo'</span> =&gt; <span class="string">'bar'</span>]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>获取请求返回结果<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$body</span> = <span class="variable">$response</span>-&gt;getBody();</span><br><span class="line"><span class="variable">$result</span> = json_decode(<span class="variable">$body</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="3-请求选项-request-options"><a href="#3-请求选项-request-options" class="headerlink" title="3.请求选项 request options"></a>3.请求选项 request options</h2><p>上述 query、form_params、json 都属于请求选项，多个请求选项组成的数组作为发起请求的第三个参数，第三个参数是请求格式、内容、超时、header、cookie等的集合<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置请求header</span></span><br><span class="line">$client-&gt;request(<span class="string">'GET'</span>, <span class="string">'/get'</span>, [<span class="string">'headers'</span> =&gt; [<span class="string">'X-Foo'</span> =&gt; <span class="string">'test'</span>]);</span><br><span class="line"><span class="comment">//设置请求超时时间</span></span><br><span class="line">$client-&gt;request(<span class="string">'GET'</span>, <span class="string">'/delay/5'</span>, [<span class="string">'connect_timeout'</span> =&gt; <span class="number">3.14</span>]);</span><br><span class="line"><span class="comment">//同时设置请求头和请求体</span></span><br><span class="line">$client-&gt;request(<span class="string">'GET'</span>, <span class="string">'/get'</span>, [<span class="string">'headers'</span> =&gt; [<span class="string">'X-Foo'</span> =&gt; <span class="string">'test'</span>], <span class="string">'json'</span> =&gt; [<span class="string">'foo'</span> =&gt; <span class="string">'bar'</span>]);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;What is the difference between form data and request payload?&lt;/p&gt;
&lt;p&gt;if a request (typically POST) has Content-type header set to application/x-www-form-urlencoded the body is expected to be in the form of a standard querystring with url-encoded key=value pairs joined by &amp;amp;. Form data section then shows the key-value parameters (when viewed parsed). This way was much more common in past because it is a default for HTML forms. other cases are shown in Request payload section (and nowadays parsed for readability as well for common formats like JSON).&lt;/p&gt;
&lt;p&gt;Form Data 和 Request Payload 区别&lt;/p&gt;
&lt;p&gt;如果请求头里设置&lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt;，那么这个请求被认为是表单请求，参数出现在&lt;code&gt;Form Data&lt;/code&gt;里，格式为&lt;code&gt;key=value&amp;amp;key=value&amp;amp;key=value...&lt;/code&gt;原生的&lt;code&gt;AJAX&lt;/code&gt;请求头里设置&lt;code&gt;Content-Type:application/json&lt;/code&gt;，或者使用默认的请求头&lt;code&gt;Content-Type:text/plain&lt;/code&gt;;参数会显示在&lt;code&gt;Request payload&lt;/code&gt;块里提交。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="http" scheme="https://upeng.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Redis常用命令学习总结</title>
    <link href="https://upeng.github.io/2018/03/26/redis-commands/"/>
    <id>https://upeng.github.io/2018/03/26/redis-commands/</id>
    <published>2018-03-26T03:58:25.000Z</published>
    <updated>2022-11-08T04:26:30.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis命令总结<br><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">http://redisdoc.com/index.html</a></p></blockquote><h1 id="场景1：字符串"><a href="#场景1：字符串" class="headerlink" title="场景1：字符串"></a>场景1：字符串</h1><p>redis的key-value结构中，value是字符串，起缓存作用，可设置过期时间，比如session，适用于读比较频繁的场景</p><p>常用命令<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GET</span> <span class="keyword">key</span></span><br><span class="line">SETEX <span class="keyword">key</span> <span class="keyword">seconds</span> <span class="keyword">value</span></span><br><span class="line">PSETEX <span class="keyword">key</span> milliseconds <span class="keyword">value</span></span><br><span class="line">SETNX <span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">MGET <span class="keyword">key</span> [<span class="keyword">key</span> ...]</span><br><span class="line">MSET <span class="keyword">key</span> <span class="keyword">value</span> [<span class="keyword">key</span> <span class="keyword">value</span> ...]</span><br><span class="line">INCR <span class="keyword">key</span>(INCRBY <span class="keyword">key</span> <span class="keyword">increment</span>)</span><br><span class="line">DECR <span class="keyword">key</span>(DECRBY <span class="keyword">key</span> <span class="keyword">decrement</span>)</span><br></pre></td></tr></table></figure></p><h1 id="场景2：哈希表"><a href="#场景2：哈希表" class="headerlink" title="场景2：哈希表"></a>场景2：哈希表</h1><p>redis的key-value结构中，value是哈希表结构，那什么是哈希表呢？</p><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。</p><p>在redis中的使用场景，比如系统只分配一个redis的key给我们，现在需要存储各个用户在每条的访问量；key可以设置成日期相关，value是各个用户及其访问量；</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">key:</span>  <span class="string">pv_20180323</span></span><br><span class="line"><span class="attr">value:</span></span><br><span class="line"><span class="string">tayloryu</span> <span class="number">80</span></span><br><span class="line"><span class="string">xiaoming</span> <span class="number">90</span></span><br><span class="line"><span class="string">zhangsan</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>还比如每条数据上报的错误量，发送量，接收量，按天，按小时，按分钟设置成field，像目前的模调、Agent业务<br><a id="more"></a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>HSET key field value</code> 将哈希表 key 中的域 field 的值设为 value 。 如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。 如果域 field 已经存在于哈希表中，旧值将被覆盖。</p><p><code>HGET key field</code> 返回哈希表 key 中给定域 field 的值。</p><p><code>HGETALL key</code> 返回哈希表 key 中，所有的域和值。 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p><p><code>HMSET key field value [field value ...]</code> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p><code>HMGET key field [field ...]</code> 返回哈希表 key 中，一个或多个给定域的值。 如果给定的域不存在于哈希表，那么返回一个 nil 值。 因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</p><p><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></p><p><code>HSETNX key field value</code> 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。 若域 field 已经存在，该操作无效。 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。</p><p><code>HKEYS key</code> 返回哈希表 key 中的所有域。</p><p><code>HVALS key</code> 返回哈希表 key 中所有域的值。</p><p><code>HLEN key</code> 返回哈希表 key 中域的数量。</p><p><code>HEXISTS key field</code> 查看哈希表 key 中，给定域 field 是否存在。</p><p><code>HDEL key field [field ...]</code> 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;redis命令总结&lt;br&gt;&lt;a href=&quot;http://redisdoc.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://redisdoc.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;场景1：字符串&quot;&gt;&lt;a href=&quot;#场景1：字符串&quot; class=&quot;headerlink&quot; title=&quot;场景1：字符串&quot;&gt;&lt;/a&gt;场景1：字符串&lt;/h1&gt;&lt;p&gt;redis的key-value结构中，value是字符串，起缓存作用，可设置过期时间，比如session，适用于读比较频繁的场景&lt;/p&gt;
&lt;p&gt;常用命令&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SETEX &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PSETEX &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; milliseconds &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SETNX &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MGET &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; ...]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MSET &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; ...]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INCR &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;(INCRBY &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;increment&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DECR &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;(DECRBY &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;decrement&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;场景2：哈希表&quot;&gt;&lt;a href=&quot;#场景2：哈希表&quot; class=&quot;headerlink&quot; title=&quot;场景2：哈希表&quot;&gt;&lt;/a&gt;场景2：哈希表&lt;/h1&gt;&lt;p&gt;redis的key-value结构中，value是哈希表结构，那什么是哈希表呢？&lt;/p&gt;
&lt;p&gt;哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。&lt;/p&gt;
&lt;p&gt;在redis中的使用场景，比如系统只分配一个redis的key给我们，现在需要存储各个用户在每条的访问量；key可以设置成日期相关，value是各个用户及其访问量；&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;key:&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;pv_20180323&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;value:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;tayloryu&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;xiaoming&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;90&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;zhangsan&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还比如每条数据上报的错误量，发送量，接收量，按天，按小时，按分钟设置成field，像目前的模调、Agent业务&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://upeng.github.io/categories/Redis/"/>
    
    
      <category term="redis" scheme="https://upeng.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Validator自定义参数验证规则</title>
    <link href="https://upeng.github.io/2017/10/18/laravel-validator/"/>
    <id>https://upeng.github.io/2017/10/18/laravel-validator/</id>
    <published>2017-10-18T15:10:58.000Z</published>
    <updated>2022-11-07T03:13:42.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义参数验证规则"><a href="#自定义参数验证规则" class="headerlink" title="自定义参数验证规则"></a>自定义参数验证规则</h2><p><code>public Validator make(array $data, array $rules, array $messages = [], array $attributes = [])</code></p><p><strong>参数说明</strong></p><ul><li><code>$data</code>是要验证的数据,即 <code>$request-&gt;all()  | $request-&gt;input() | Request::all()</code></li><li><code>$rules</code>是验证的规则</li><li><code>$messages</code>是提示信息，自定义<code>rules</code>中的规则信息</li><li><code>$attributes</code>是设置属性别名</li></ul><blockquote><p>使用方法和流程见示例</p></blockquote><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $data = $request-&gt;input();</span><br><span class="line">    $rules = [</span><br><span class="line">        <span class="string">'id'</span>    =&gt; <span class="string">'required|numeric'</span>,</span><br><span class="line">        <span class="string">'age'</span>   =&gt; <span class="string">'required|numeric|max:150'</span>,</span><br><span class="line">        <span class="string">'name'</span>  =&gt; <span class="string">'sometimes|max:20'</span>,  <span class="comment">//sometimes的用意（不传则已，传则必须遵守规则）</span></span><br><span class="line">    ];</span><br><span class="line">    $messages = [</span><br><span class="line">        <span class="string">'required'</span>  =&gt; <span class="string">':attribute不能为空'</span>,</span><br><span class="line">        <span class="string">'numeric'</span>   =&gt; <span class="string">':attribute必须是数字'</span>,</span><br><span class="line">        <span class="string">'max'</span>       =&gt; <span class="string">':attribute长度（数值）不应该大于 :max'</span>,</span><br><span class="line">    ];</span><br><span class="line">    $attributes = [</span><br><span class="line">        <span class="string">'id'</span>    =&gt; <span class="string">'ID'</span>,</span><br><span class="line">        <span class="string">'age'</span>   =&gt; <span class="string">'年龄'</span>,</span><br><span class="line">        <span class="string">'name'</span>  =&gt; <span class="string">'名称'</span>,</span><br><span class="line">    ];</span><br><span class="line">    $validator = \Validator::make($data, $rules, $messages, $attributes);</span><br><span class="line">    <span class="keyword">if</span> ($validator-&gt;fails()) &#123;</span><br><span class="line">        <span class="keyword">return</span> $validator-&gt;errors()-&gt;all();         <span class="comment">//显示所有错误组成的数组</span></span><br><span class="line">        <span class="comment">//return $validator-&gt;errors()-&gt;first();     //显示第一条错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'validate passed'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的messages和attributes都是在使用处自定义设置，有种方法是按照语言在配置文件中定义</p></blockquote><ol><li>修改config/app.php里面的locale为ch</li><li>新建 lang/ch/validation.php 文件</li><li>修改validation.php文件，可将提示信息修改为中文，attributes是设置属性别名。</li></ol><p>另外custom是完全自定义<br><code>Here you may specify custom validation messages for attributes using the convention &quot;attribute.rule&quot; to name the lines. This makes it quick to specify a specific custom language line for a given attribute rule.</code><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'custom'</span> =&gt; [</span><br><span class="line">    <span class="string">'age'</span> =&gt; [</span><br><span class="line">        <span class="string">'required'</span> =&gt; <span class="string">'年龄必须存在'</span>,</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义参数验证规则&quot;&gt;&lt;a href=&quot;#自定义参数验证规则&quot; class=&quot;headerlink&quot; title=&quot;自定义参数验证规则&quot;&gt;&lt;/a&gt;自定义参数验证规则&lt;/h2&gt;&lt;p&gt;&lt;code&gt;public Validator make(array $data, array $rules, array $messages = [], array $attributes = [])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$data&lt;/code&gt;是要验证的数据,即 &lt;code&gt;$request-&amp;gt;all()  | $request-&amp;gt;input() | Request::all()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$rules&lt;/code&gt;是验证的规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$messages&lt;/code&gt;是提示信息，自定义&lt;code&gt;rules&lt;/code&gt;中的规则信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$attributes&lt;/code&gt;是设置属性别名&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用方法和流程见示例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="laravel" scheme="https://upeng.github.io/tags/laravel/"/>
    
      <category term="validator" scheme="https://upeng.github.io/tags/validator/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令之sed</title>
    <link href="https://upeng.github.io/2017/09/28/linux-sed/"/>
    <id>https://upeng.github.io/2017/09/28/linux-sed/</id>
    <published>2017-09-28T14:23:10.000Z</published>
    <updated>2022-11-07T03:13:42.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed工作原理："><a href="#sed工作原理：" class="headerlink" title="sed工作原理："></a>sed工作原理：</h2><p>sed在正常情况下，将处理的行读入模式空间，脚本中的sed命令就一条接着一条进行处理，直到脚本执行完毕。然后该行被输出，模式空间被清空；接着，在重复执行刚才的动作，文件中的新的一行被读入，直到文件处理完毕。【读入的每一行删除行尾的换行符放入模式空间，再执行所有命令，执行完所有的命令之后，再加回删过的换行符并打印到输出】</p><h2 id="sed替换操作（s命令）"><a href="#sed替换操作（s命令）" class="headerlink" title="sed替换操作（s命令）"></a>sed替换操作（s命令）</h2><ul><li>使用后缀 <code>/g</code> 标记会替换每一行中的所有匹配, <code>/n</code>表示替换每一行第n处匹配</li><li><code>sed -i</code> 表示在源文件基础上修改</li></ul><a id="more"></a><p><code>sed &#39;s/^/str&amp;/g&#39; filename</code>              //每行前加上字符串str<br><code>sed &#39;s/$/&amp;str/g&#39; filename</code>               //每行末尾加上字符串str</p><p><code>sed &#39;s/oldstr/newstr/g&#39; filename</code>      //字符串替换</p><p><code>sed &#39;s/str/,str/g&#39; filename</code>           //str前加上逗号，本质上还是字符串替换<br><code>sed &#39;s/str//g&#39; filename</code>               //删除字符串str，本质上还是字符串替换<br><code>sed &#39;s/str.*//g&#39; filename</code>              //删除字符串str之后的所有字符（包括str）</p><p><code>sed &#39;s/\s\+/,/g&#39; filename</code>     //替换一个或多个空格为逗号，其中\s代表空格，+代表出现一次或多次。<br><code>sed &#39;s/\t/,/g&#39;    filename</code>        //替换tab为逗号</p><p><code>s/^/hello\n&amp;/g filename</code>        //每一行前面加上一行hello</p><h2 id="组合多个表达式-多个sed命令"><a href="#组合多个表达式-多个sed命令" class="headerlink" title="组合多个表达式(多个sed命令)"></a>组合多个表达式(多个sed命令)</h2><p>一定要注意顺序，因为多个命令前后是有依赖的，每一个命令都是在前一个命令执行完成的基础上进行的，数据自然也是前一个命令处理后的数据。<br><strong>使用方法：</strong></p><ol><li><code>sed &#39;表达式&#39; | sed &#39;表达式&#39;</code></li><li><code>sed &#39;表达式; 表达式&#39;</code></li></ol><h2 id="sed的其他命令参考"><a href="#sed的其他命令参考" class="headerlink" title="sed的其他命令参考"></a>sed的其他命令参考</h2><p><a href="http://man.linuxde.net/sed" target="_blank" rel="noopener">http://man.linuxde.net/sed</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sed工作原理：&quot;&gt;&lt;a href=&quot;#sed工作原理：&quot; class=&quot;headerlink&quot; title=&quot;sed工作原理：&quot;&gt;&lt;/a&gt;sed工作原理：&lt;/h2&gt;&lt;p&gt;sed在正常情况下，将处理的行读入模式空间，脚本中的sed命令就一条接着一条进行处理，直到脚本执行完毕。然后该行被输出，模式空间被清空；接着，在重复执行刚才的动作，文件中的新的一行被读入，直到文件处理完毕。【读入的每一行删除行尾的换行符放入模式空间，再执行所有命令，执行完所有的命令之后，再加回删过的换行符并打印到输出】&lt;/p&gt;
&lt;h2 id=&quot;sed替换操作（s命令）&quot;&gt;&lt;a href=&quot;#sed替换操作（s命令）&quot; class=&quot;headerlink&quot; title=&quot;sed替换操作（s命令）&quot;&gt;&lt;/a&gt;sed替换操作（s命令）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用后缀 &lt;code&gt;/g&lt;/code&gt; 标记会替换每一行中的所有匹配, &lt;code&gt;/n&lt;/code&gt;表示替换每一行第n处匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed -i&lt;/code&gt; 表示在源文件基础上修改&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://upeng.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://upeng.github.io/tags/linux/"/>
    
      <category term="sed" scheme="https://upeng.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本由点到面学习总结</title>
    <link href="https://upeng.github.io/2017/09/27/shell-script-learning/"/>
    <id>https://upeng.github.io/2017/09/27/shell-script-learning/</id>
    <published>2017-09-27T14:38:00.000Z</published>
    <updated>2022-11-07T03:13:42.759Z</updated>
    
    <content type="html"><![CDATA[<p>以前只是零零散散写过一些简单的命令行，比如awk、sed、nc、ls、comm这些简单的命令，几乎没有写过一个完整的shell脚本，像循环、条件判断、数据库操作等几乎都没怎么写过，总觉得shell写起来太麻烦，要学习的东西太多了，其实主要是懒。这次由于业务需要，使用shell脚本能方便解决问题，便硬着头皮上了，借着这个机会把常用的命令整理一下，算作温习吧。</p><h2 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a>实现功能：</h2><p>将下面未经处理的原始数据，批量导入到es，并记录导入的数据源；<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete3   CD      <span class="number">1.1977199809152</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete4   CD      <span class="number">5.856237342947999</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete5   CD      <span class="number">5.1901199172992</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete6   CD      <span class="number">0.748574988072</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete7   CD      <span class="number">2.4472449769392</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete8   CD      <span class="number">9.62620145261278</span></span><br><span class="line"><span class="symbol">20170101 </span>       ABCD-EF-G001-<span class="number">12345678</span>    <span class="number">1</span>rt2xete9   CD      <span class="number">0.1249524996024</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h2><ul><li>数据量很大，从1月1号到9月20号，每天一个文件，每个文件大概100w行（约100M），导入es通过http请求，虽然es支持批量bulk导入，但是批量数据大小是有限度的，超过大小直接kill掉</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>导入到es的数据源需要完整记录备份，作为日志，如果导入失败可以补录。</li><li>虽然数据源每天一个文件堆在一起，但是日志却不能每个文件都放在一个文件夹里，所以需要设计成按年月（如201701,201702）分为一级文件夹，然后按天（如01,02…30）分为二级文件夹,每个文件夹存储当天的源文件，切割文件等信息</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p><strong>step1：</strong> 获取日期参数，格式Ymd，如果不传则默认取当天日期</p><p><strong>step2：</strong> 根据日期获取源文件（源文件格式<code>年月日.txt</code>）</p><p><strong>step3：</strong> 定义输出文件目录格式</p><p><strong>step4：</strong> 定义es数据源文件</p><p><strong>step5：</strong> 将源文件格式化成es数据原文件，用到sed命令</p><p><strong>step6：</strong> 将es数据源文件进行切割，用到split命令</p><p><strong>step7：</strong> 获取切割后的文件组成数组</p><p><strong>step8：</strong> 循环调用es接口批量入数据</p><h2 id="子脚本剖析"><a href="#子脚本剖析" class="headerlink" title="子脚本剖析"></a>子脚本剖析</h2><blockquote><p>step1</p></blockquote><p>1）条件判断 if [condition]; then command1 else command2 fi<br>2）获取命令行参数 $，$0，$1…<br>3）复杂条件判断，多个if else;switch case<br> 详细【待总结】</p><p>自定义日期格式<br>如：<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>详细【待总结】 参考：<br> <a href="http://blog.csdn.net/shanliangliuxing/article/details/16821175" target="_blank" rel="noopener">http://blog.csdn.net/shanliangliuxing/article/details/16821175</a><br> <a href="http://blog.csdn.net/jk110333/article/details/8590746" target="_blank" rel="noopener">http://blog.csdn.net/jk110333/article/details/8590746</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; then </span><br><span class="line"><span class="attribute">DATE</span>=`date +%Y%m%d`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="attribute">DATE</span>=<span class="variable">$1</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><blockquote><p>step2</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">source_file_path</span>=/data/codes</span><br><span class="line"><span class="attr">source_file</span>=<span class="variable">$source_file_path</span>/<span class="variable">$DATE</span>.txt</span><br></pre></td></tr></table></figure><blockquote><p>step3</p></blockquote><p>定义年月、日目录名称, 递归创建多层文件目录<br>判断文件或目录是否存在，<code>（-d -f）</code><br>详细【待总结】<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">folderYearMonth</span>=`date -d <span class="variable">$DATE</span> +<span class="string">"%Y%m"</span>`</span><br><span class="line"><span class="attribute">folderDay</span>=`date -d <span class="variable">$DATE</span> +<span class="string">"%d"</span>`</span><br><span class="line"><span class="attribute">output_file_path</span>=/data/home/upeng/$folderYearMonth/$folderDay</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$output_file_path</span>"</span> ]; then</span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$output_file_path</span>"</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><blockquote><p>step4</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">es_source_file</span>=<span class="variable">$output_file_path</span>/<span class="variable">$DATE</span>.json</span><br><span class="line"><span class="attr">start_at</span>=$(date +%s)  //转换成时间戳</span><br></pre></td></tr></table></figure><blockquote><p>step5</p></blockquote><p><code>sed</code>命令总结；多个<code>sed</code>同时编辑，理解步骤先后顺序，详细【待总结】<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed '<span class="keyword">s</span>/\t/,/g<span class="comment">;</span></span><br><span class="line"><span class="keyword">s</span>/^/&#123;<span class="string">"date"</span>:<span class="string">"&amp;/g;</span></span><br><span class="line"><span class="string">s/,/"</span>,<span class="string">"code"</span>:<span class="string">"/1;</span></span><br><span class="line"><span class="string">s/,/"</span>,<span class="string">"oid"</span>:<span class="string">"/2;</span></span><br><span class="line"><span class="string">s/,/"</span>,<span class="string">"type"</span>:<span class="string">"/3;</span></span><br><span class="line"><span class="string">s/,/"</span>,<span class="string">"salary"</span>:<span class="string">"/4;s/$/&amp;"</span>&#125;/g<span class="comment">;</span></span><br><span class="line"><span class="keyword">s</span>/^/&#123;<span class="string">"index"</span>:&#123;&#125;&#125;\n&amp;/g' <span class="built_in">$source</span>_file &gt; <span class="built_in">$es</span>_source_file</span><br></pre></td></tr></table></figure></p><blockquote><p>step6</p></blockquote><p><code>split</code> 文件切割，详细【待总结】<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">split</span> -l <span class="number">500000</span> $es_source_file $output_file_path/$date_</span><br></pre></td></tr></table></figure></p><blockquote><p>step7</p></blockquote><p><code>awk</code>、数组，详细【待总结】<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arrs</span>=($(ls -l <span class="variable">$output_file_path</span>/<span class="variable">$date_</span>* | awk <span class="string">'&#123;print $9&#125;'</span>))</span><br></pre></td></tr></table></figure></p><blockquote><p>step8</p></blockquote><p>循环调用<code>es</code>接口批量入数据，详细【待总结】<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arr <span class="keyword">in</span> <span class="variable">$&#123;arrs[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">curl -XPOST <span class="string">'http://127.0.0.1:9200/media/order/_bulk?pretty'</span> --data-binary @<span class="variable">$arr</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">end_at=$(date +%s)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"it takes <span class="variable">$((end_at-start_at)</span>) seconds"</span></span><br></pre></td></tr></table></figure></p><h2 id="父脚本剖析"><a href="#父脚本剖析" class="headerlink" title="父脚本剖析"></a>父脚本剖析</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">source_file_path</span>=/data/codes</span><br><span class="line"><span class="attribute">script_path</span>=/data/home/upeng</span><br><span class="line">cd <span class="variable">$source_file_path</span></span><br><span class="line">DATES=($(ls -l *<span class="string">".txt"</span> | awk <span class="string">'&#123;print $9&#125;'</span> | awk -F <span class="string">'.'</span> <span class="string">'&#123;print $1&#125;'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> <span class="variable">$&#123;DATES[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="attribute">folderYm</span>=`date -d <span class="variable">$DATES</span> +<span class="string">"%Y%m"</span>`</span><br><span class="line"><span class="attribute">folderD</span>=`date -d <span class="variable">$DATES</span> +<span class="string">"%d"</span>`</span><br><span class="line"><span class="attribute">output_file_path</span>=<span class="variable">$script_path</span>/$folderYm/$folderD</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$output_file_path</span>"</span> ]; then</span><br><span class="line">sh <span class="variable">$script_path</span>/child_script.sh <span class="variable">$date</span></span><br><span class="line">cat /dev/<span class="literal">null</span> &gt; <span class="variable">$script_path</span>/nohup.out</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ol><li>上述脚本中<code>待总结</code>的部分是每个点需要完善的面</li><li>上述脚本还有诸多待完善部分，当前只是能够运行，异常情况如何处理如何捕获待整理</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前只是零零散散写过一些简单的命令行，比如awk、sed、nc、ls、comm这些简单的命令，几乎没有写过一个完整的shell脚本，像循环、条件判断、数据库操作等几乎都没怎么写过，总觉得shell写起来太麻烦，要学习的东西太多了，其实主要是懒。这次由于业务需要，使用shell脚本能方便解决问题，便硬着头皮上了，借着这个机会把常用的命令整理一下，算作温习吧。&lt;/p&gt;
&lt;h2 id=&quot;实现功能：&quot;&gt;&lt;a href=&quot;#实现功能：&quot; class=&quot;headerlink&quot; title=&quot;实现功能：&quot;&gt;&lt;/a&gt;实现功能：&lt;/h2&gt;&lt;p&gt;将下面未经处理的原始数据，批量导入到es，并记录导入的数据源；&lt;br&gt;&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete3   CD      &lt;span class=&quot;number&quot;&gt;1.1977199809152&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete4   CD      &lt;span class=&quot;number&quot;&gt;5.856237342947999&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete5   CD      &lt;span class=&quot;number&quot;&gt;5.1901199172992&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete6   CD      &lt;span class=&quot;number&quot;&gt;0.748574988072&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete7   CD      &lt;span class=&quot;number&quot;&gt;2.4472449769392&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete8   CD      &lt;span class=&quot;number&quot;&gt;9.62620145261278&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;20170101 &lt;/span&gt;       ABCD-EF-G001-&lt;span class=&quot;number&quot;&gt;12345678&lt;/span&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;rt2xete9   CD      &lt;span class=&quot;number&quot;&gt;0.1249524996024&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://upeng.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://upeng.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://upeng.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Eloquent ORM多个and和or条件查询</title>
    <link href="https://upeng.github.io/2017/09/14/laravel-eloquent-index/"/>
    <id>https://upeng.github.io/2017/09/14/laravel-eloquent-index/</id>
    <published>2017-09-14T14:38:00.000Z</published>
    <updated>2022-11-07T03:13:42.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Eloquent-ORM和查询构造器Query-Builder"><a href="#Eloquent-ORM和查询构造器Query-Builder" class="headerlink" title="Eloquent ORM和查询构造器Query Builder"></a>Eloquent ORM和查询构造器Query Builder</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model::all();</span><br><span class="line">Model::where();</span><br><span class="line">Model::groupBy<span class="function"><span class="params">()</span>-&gt;</span>select<span class="function"><span class="params">(<span class="string">'field_name'</span>)</span>-&gt;</span>get<span class="function"><span class="params">()</span>-&gt;</span>toArray()</span><br></pre></td></tr></table></figure><p>之前一直使用ORM，后面可以尝试使用查询构造器，ORM相比查询构造器，不需要指定table_name和field等信息，但是也有局限性，比如我们经常会需要查询指定字段field<br>对于查询构造器而言是十分方便的select字段名接近原生查询方法，易理解易记忆。<br><a id="more"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$users = DB::table(<span class="string">'users'</span>)-&gt;select(<span class="string">'name'</span>, <span class="string">'email'</span>)-&gt;get();</span><br><span class="line"><span class="comment">//那么ORM是否无法查询指定字段呢？当然不是,ORM也是可以滴</span></span><br><span class="line">Market::all([*])</span><br><span class="line"><span class="comment">//将Model类作为一个obj，然后链式操作</span></span><br><span class="line">$market = Marketer::query(); </span><br><span class="line"><span class="comment">//根据条件选择性地执行下面的条件</span></span><br><span class="line">$market-&gt;where();</span><br></pre></td></tr></table></figure></p><p>查询构造可以指定tablename为某个Model的static变量,便于维护。当然查询构造器有很多很好用的查询方式，而且链式操作强悍，实例：<a href="https://cs.laravel-china.org/#db" target="_blank" rel="noopener">查询构造器</a></p><h3 id="踩到的一个坑"><a href="#踩到的一个坑" class="headerlink" title="踩到的一个坑"></a>踩到的一个坑</h3><blockquote><p>多个or和and条件查询</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span><span class="built_in"> users </span>where (<span class="attribute">id</span>=2 <span class="keyword">or</span> <span class="attribute">name</span>=<span class="string">'taylor'</span> <span class="keyword">or</span> <span class="attribute">age</span>=27) <span class="keyword">and</span> <span class="attribute">address</span>=<span class="string">'shanghai'</span></span><br><span class="line"></span><br><span class="line">Users::where(id, 2)</span><br><span class="line">    -&gt;orWhere(name, <span class="string">'taylor'</span>)</span><br><span class="line">    -&gt;orWhere(age, 27)</span><br><span class="line">    -&gt;where(address, <span class="string">'shanghai'</span>)</span><br></pre></td></tr></table></figure><p>发现结果和预期不同，因为<code>and</code>逻辑会先于<code>or</code>，所以会出现问题，那么如何<strong>按照我们指定的顺序</strong>去查询？官方手册并未这么详细，在Stack Overflow找到了答案：<br><a href="https://stackoverflow.com/questions/30434037/laravel-5-eloquent-where-and-or-in-clauses" target="_blank" rel="noopener">Laravel 5 Eloquent where and or in Clauses</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$market-&gt;where( &#123;</span><br><span class="line">Users::where(<span class="function"><span class="keyword">function</span><span class="params">($q)</span></span>&#123;</span><br><span class="line">    $q-&gt;where(<span class="string">'id'</span>, <span class="number">2</span>)</span><br><span class="line">    -&gt;orWhere(<span class="string">'name'</span>, <span class="string">'taylor'</span>)</span><br><span class="line">    -&gt;orWhere(<span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line">&#125;)-&gt;where(<span class="string">'address'</span>, <span class="string">'shanghai'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">继续，还有坑，因为我们传递的都是数值和字符串，正常情况是变量</span><br><span class="line"></span><br><span class="line">$id = <span class="number">2</span>;</span><br><span class="line">$market-&gt;where( &#123;</span><br><span class="line">Users::where(<span class="function"><span class="keyword">function</span><span class="params">($q)</span></span>&#123;</span><br><span class="line">    $q-&gt;where(<span class="string">'id'</span>, $id)</span><br><span class="line">    -&gt;orWhere(<span class="string">'name'</span>, <span class="string">'taylor'</span>)</span><br><span class="line">    -&gt;orWhere(<span class="string">'age'</span>, <span class="number">27</span>)</span><br><span class="line">&#125;)-&gt;where(<span class="string">'address'</span>, <span class="string">'shanghai'</span>);</span><br></pre></td></tr></table></figure><p><code>Error: $id is not definied</code><br><code>Reason:</code> 匿名函数内部的<code>where</code>和<code>orWhere</code>是一起的（括号），但是在匿名函数内是取不到其外部的变量的，可以在<code>function</code>内部传参数解决，也可以将变量赋值成成员变量解决；<br>比如<code>$this-&gt;id = 2；</code>这样可以 将<code>$id</code> 改成<code>$this-&gt;id</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Eloquent-ORM和查询构造器Query-Builder&quot;&gt;&lt;a href=&quot;#Eloquent-ORM和查询构造器Query-Builder&quot; class=&quot;headerlink&quot; title=&quot;Eloquent ORM和查询构造器Query Builder&quot;&gt;&lt;/a&gt;Eloquent ORM和查询构造器Query Builder&lt;/h3&gt;&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Model::all();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model::where();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Model::groupBy&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;select&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&#39;field_name&#39;&lt;/span&gt;)&lt;/span&gt;-&amp;gt;&lt;/span&gt;get&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;-&amp;gt;&lt;/span&gt;toArray()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之前一直使用ORM，后面可以尝试使用查询构造器，ORM相比查询构造器，不需要指定table_name和field等信息，但是也有局限性，比如我们经常会需要查询指定字段field&lt;br&gt;对于查询构造器而言是十分方便的select字段名接近原生查询方法，易理解易记忆。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="laravel" scheme="https://upeng.github.io/tags/laravel/"/>
    
      <category term="eloquent" scheme="https://upeng.github.io/tags/eloquent/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用压缩解压缩命令</title>
    <link href="https://upeng.github.io/2017/09/10/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4-index/"/>
    <id>https://upeng.github.io/2017/09/10/Linux压缩解压缩命令-index/</id>
    <published>2017-09-10T13:00:00.000Z</published>
    <updated>2022-11-07T03:13:42.744Z</updated>
    
    <content type="html"><![CDATA[<p><strong>tar后缀文件</strong><br>//解包<br><code>tar xvf FileName.tar</code><br>//打包<br><code>tar cvf FileName.tar DirName</code></p><p><strong>zip后缀文件</strong><br>//解压<br><code>unzip FileName.zip</code><br>//压缩<br><code>zip FileName.zip DirName</code><br>压缩一个目录使用 -r 参数，-r 递归。例： <code>$ zip -r FileName.zip DirName</code></p><a id="more"></a><p><strong>tar.gz 和 .tgz后缀文件</strong><br>//解压<br><code>tar zxvf FileName.tar.gz</code><br>//压缩<br><code>tar zcvf FileName.tar.gz DirName</code></p><p><strong>rar后缀文件</strong><br>//解压<br><code>rar x FileName.rar</code><br>//压缩<br><code>rar a FileName.rar DirName</code><br>rar请到：<code>http://www.rarsoft.com/download.htm</code> 下载！<br>解压后请将<code>rar_static</code>拷贝到<code>/usr/bin</code>目录（其他由$PATH环境变量指定的目录也可以）：<br><code>[root@www]# cp rar_static /usr/bin/rar</code>　　</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;tar后缀文件&lt;/strong&gt;&lt;br&gt;//解包&lt;br&gt;&lt;code&gt;tar xvf FileName.tar&lt;/code&gt;&lt;br&gt;//打包&lt;br&gt;&lt;code&gt;tar cvf FileName.tar DirName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zip后缀文件&lt;/strong&gt;&lt;br&gt;//解压&lt;br&gt;&lt;code&gt;unzip FileName.zip&lt;/code&gt;&lt;br&gt;//压缩&lt;br&gt;&lt;code&gt;zip FileName.zip DirName&lt;/code&gt;&lt;br&gt;压缩一个目录使用 -r 参数，-r 递归。例： &lt;code&gt;$ zip -r FileName.zip DirName&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://upeng.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://upeng.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vuejs与后台数据的交互实践</title>
    <link href="https://upeng.github.io/2016/12/17/vuejs/"/>
    <id>https://upeng.github.io/2016/12/17/vuejs/</id>
    <published>2016-12-17T07:58:17.000Z</published>
    <updated>2022-11-07T03:13:42.762Z</updated>
    
    <content type="html"><![CDATA[<p>Vuejs是MVVM框架，数据和DOM视图双向绑定，数据驱动的 web 界面的库。</p><p><strong>响应的数据绑定</strong>：数据与DOM保持同步非常简单，数据发生变化的时候，如果我们使用JQuery操作DOM的话自然是可行的，但是jQuery操作DOM代码复杂容易出错，就拿一个简单的例子，在列表中新增一行数据，使用JQuery可能会刷新整个DOM,并对页面refresh。但是vue实现数据与DOM的绑定后，只要数据发生变化，就自动改动DOM，所以我们的工作重点就是修改数据，不必与DOM更新搅在一起。</p><p><strong>我的理解</strong>：Vuejs简化了操作DOM或者不再去手动操作DOM，一个简单的API就搞定了DOM的自动更新，让我们脱离了使用Js操作DOM的复杂流程。这也是Vue的迷人之处吧，其他的优点诸如：组件化、模块化、体积小等优点我就不再罗列了，本文重点也不在此。<br><a id="more"></a><br>那么问题来了</p><h2 id="vuejs与后端（比如PHP）是如何交互的？"><a href="#vuejs与后端（比如PHP）是如何交互的？" class="headerlink" title="vuejs与后端（比如PHP）是如何交互的？"></a>vuejs与后端（比如PHP）是如何交互的？</h2><p>怎么使用Vuejs与后台数据（这里是指后台的数据库，不是vuejs的model，因为我理解的vuejs的model仍是前端数据）交互？其实这个问题本身就存在问题，（这是最初是对vuejs不怎么了解的情况下做出的提问），事实上vuejs <strong>关注点</strong>是如何优雅的操作DOM或者减少手动操作DOM，至于与后台的交互，这是js（当然vuejs也是基于js啊）要做的事情，所以<strong>正确的提问姿势</strong>应该是：<em>js怎样和后端交互？</em> 那么现在这个问题就变得简单了。我们知道js是不能直接操作数据库的，但是ajax却架起前后端的桥梁，能让前后端数据进行交互。</p><blockquote><p>当然vuejs作为js衍生出的框架，它除了具有js的特性外，还有自己的特色呢，所以vuejs可以使用vue-resource来与后端交互。</p></blockquote><p>下面使用ajax(基于jquery)、vuejs、php实现简单的数据的增删改查。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'http://localhost:8080/vuejs/api/book.php'</span>;</span><br><span class="line">getJson(<span class="built_in">url</span>, pushDom);</span><br></pre></td></tr></table></figure><p>分析getJson函数【已经封装】</p><ol><li>初始化信息列表</li><li>两个参数：<br>（1）第一个是获取列表的接口地址url；<br>（2）第二个是回调函数名</li><li>流程分析：<br>在getJson中通过ajax调取接口url获取数据data，然后将data作为参数调用pushDom函数，pushDom是展示、或者使用vue操作DOM的功能函数。那么怎么使用jquey、ajax配合vue进行后端数据库增删改查。<br>首先需要对vue的增删改查机制了如指掌才行；methods事件触发，我们可以在methods中定义add、delete、modify完成数据的绑定，异步刷新显示；同时将获取的数据传递给封装好的ajax函数中，与后端交互【正确的流程应该与后台交互成功才会自动更新DOM，这里不细论】；例如<br><strong>添加数据</strong>：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    addBook:function()&#123;</span><br><span class="line">        <span class="keyword">this</span>.book.id=parseInt(postData(<span class="keyword">this</span>.book));</span><br><span class="line">        <span class="keyword">this</span>.books.push(<span class="keyword">this</span>.book);</span><br><span class="line">        <span class="keyword">this</span>.book=<span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们从前端拿到的数据<code>this.book</code>，然后调用<code>postData(this.book)</code>;<code>postData</code>就是一个与后端交互的封装了ajax的函数<br>期间遇到了一点小意外，总是获取不到ajax的返回值，关于如何获取ajax返回值和为何获取不到ajax中的值问题，<code>postData</code>函数中写的很清楚<br><code>async: false</code>, 默认是<code>true</code></p><p>代码见：<a href="https://github.com/upeng/learn-vuejs" target="_blank" rel="noopener">github</a><br>demo页：<img src="https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/vuedemo.png" alt="demo"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vuejs是MVVM框架，数据和DOM视图双向绑定，数据驱动的 web 界面的库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应的数据绑定&lt;/strong&gt;：数据与DOM保持同步非常简单，数据发生变化的时候，如果我们使用JQuery操作DOM的话自然是可行的，但是jQuery操作DOM代码复杂容易出错，就拿一个简单的例子，在列表中新增一行数据，使用JQuery可能会刷新整个DOM,并对页面refresh。但是vue实现数据与DOM的绑定后，只要数据发生变化，就自动改动DOM，所以我们的工作重点就是修改数据，不必与DOM更新搅在一起。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的理解&lt;/strong&gt;：Vuejs简化了操作DOM或者不再去手动操作DOM，一个简单的API就搞定了DOM的自动更新，让我们脱离了使用Js操作DOM的复杂流程。这也是Vue的迷人之处吧，其他的优点诸如：组件化、模块化、体积小等优点我就不再罗列了，本文重点也不在此。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://upeng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vuejs" scheme="https://upeng.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>判断一个整数的二进制中1的个数</title>
    <link href="https://upeng.github.io/2016/12/13/algorithm/"/>
    <id>https://upeng.github.io/2016/12/13/algorithm/</id>
    <published>2016-12-13T15:02:26.000Z</published>
    <updated>2022-11-07T03:13:42.745Z</updated>
    
    <content type="html"><![CDATA[<p>无意间看到这个题目，最先想到是将整数转换成二进制，然后再统计这个二进制中有多少个1。对于php而言，这很容易实现，转成二进制可用<code>decbin()</code>这个函数，然后将二进制数按1位进行分割用str_split()，最后对分割后的数值进行foreach即可完成数据的统计，实际上这是最low的解决方案，网上大多数使用下面的算法进行求解，觉得很巧妙，于是就mark了！<br><a id="more"></a></p><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a><a href="#算法说明" title="算法说明"></a>算法说明</h3><p>设x的二进制位表示为<br>x=a<sub>(n-1)</sub> a<sub>(n-2)</sub>…a<sub>0</sub></p><p>按从低位到高位的顺序，不失一般性，假设x的第i位为第一个为1的二进制位，即：a<sub>i</sub> = 1<br>此时有：<br>x = a<sub>(n-1)</sub> a<sub>(n-2)</sub> … a<sub>(i+1)</sub> 1 0 0 … 0 （式1)<br>x-1= a<sub>(n-1)</sub>a<sub>(n-2)</sub> …a<sub>(i+1)</sub> 0 1 1 … 1 （式2)<br>很明显，从式1和式2可以得出，在第一次 <code>x &amp; (x-1)</code> 后：<br>x = a<sub>(n-1)</sub> a<sub>(n-2)</sub> … a<sub>(i+1)</sub> 0 0 0 … 0</p><p>之后重复同样操作，直到x的二进制位中没有1为止，从上面可以看出，每执行过一次 <code>x &amp; (x-1)</code> 后，都会将x的<strong>二进制位中为1的最低位的值变为0，并记数加1</strong>。目前而言，一个整数最大64bit，所有三种方法执行起来都可以认为是O(1)。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><a href="#代码实现" title="代码实现"></a>代码实现</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$number = $argv[<span class="number">1</span>];</span></span><br><span class="line"><span class="php">$counter = <span class="number">0</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">while</span> ($number)</span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    $counter += <span class="number">1</span>;</span></span><br><span class="line"><span class="php">    $number = $number &amp; ($number<span class="number">-1</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">echo</span> $counter . PHP_EOL;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意间看到这个题目，最先想到是将整数转换成二进制，然后再统计这个二进制中有多少个1。对于php而言，这很容易实现，转成二进制可用&lt;code&gt;decbin()&lt;/code&gt;这个函数，然后将二进制数按1位进行分割用str_split()，最后对分割后的数值进行foreach即可完成数据的统计，实际上这是最low的解决方案，网上大多数使用下面的算法进行求解，觉得很巧妙，于是就mark了！&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://upeng.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>在编程中的幂等性idempotence</title>
    <link href="https://upeng.github.io/2016/12/08/idempotence/"/>
    <id>https://upeng.github.io/2016/12/08/idempotence/</id>
    <published>2016-12-08T14:46:55.000Z</published>
    <updated>2022-11-07T03:13:42.746Z</updated>
    
    <content type="html"><![CDATA[<p>在编程中，可能经常会听到幂等这个词，第一次是年初红包技术复盘时听到了这个词，这次是因为写脚本时被质疑，是否支持幂等。这里总结一下，也算是个记录吧。其实在编程中，很多时候都需要支持幂等，有的程序自然存在幂等，有的需要我们控制。比如与支付相关的场景，比如我们常见的HTTP方法。<br><a id="more"></a></p><h3 id="幂等性概念"><a href="#幂等性概念" class="headerlink" title="幂等性概念"></a><a href="#幂等性概念" title="幂等性概念"></a>幂等性概念</h3><p><strong>idempotence</strong>：在编程中，一个程序幂等操作的<strong>特点</strong>是其<strong>任意多次执行</strong>所产生的影响均与<strong>一次执行</strong>的影响<strong>相同</strong></p><h3 id="幂等案例"><a href="#幂等案例" class="headerlink" title="幂等案例"></a><a href="#幂等案例" title="幂等案例"></a>幂等案例</h3><p>比如你写了一个script，实现的功能是：发送短信sms和私信message通知用户，而且要求每个用户每天只发送一次。如果不进行幂等控制，会有什么问题呢？</p><h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a><a href="#存在问题" title="存在问题"></a>存在问题</h5><p>sms和message发送完成后，你通过log发现，有部分用户发送失败，这时你又不能再跑一遍脚本，因为这会导致之发送成功的用户再次收到消息，显然这是不符合业务逻辑的，而且如果还是有发送失败的，那就再跑一遍？</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><a href="#解决方案" title="解决方案"></a>解决方案</h5><ol><li><p>通过日志，筛选出发送失败的用户，重新补发，如果还是有失败的，继续补发。。。，而且！你还需单独准备一个脚本用于补发</p></li><li><p>控制脚本，实现幂等！一个脚本足以，无论发送多少次，都不会出现重复发送的情况<br>很显然，第二种才是比较专业的解决方案，那么如何实现幂等呢，方法不止一个，此处我们使用缓存。具体如下：<br>给用户发信息时，检查缓存中是否有用户发送记录，有则跳过不发送，无则发送，发送成功时设置用户缓存。</p></li></ol><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><a href="#伪代码" title="伪代码"></a>伪代码</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($uids <span class="keyword">as</span> $uid)</span><br><span class="line">&#123;</span><br><span class="line">    $cache = <span class="keyword">array</span>();</span><br><span class="line">    $cache = getCache($uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($cache[<span class="string">'sms'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sendSMS($uid))</span><br><span class="line">        &#123;</span><br><span class="line">            $cache[<span class="string">'sms'</span>] = <span class="number">1</span>;</span><br><span class="line">            setCache($uid, $cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>($cache[<span class="string">'msg'</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sendMessage($uid))</span><br><span class="line">        &#123;</span><br><span class="line">            $cache[<span class="string">'msg'</span>] = <span class="number">1</span>;</span><br><span class="line">            setCache($uid, $cache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#总结" title="总结"></a>总结</h5><p>这样一来，程序就具有简单的幂等性，脚本跑n次和跑一次影响是一致的，而且还可以弥补发送失败的情况，大不了多跑几次，因为不会出现重发的情况。<code>以后写脚本的时候，要考虑一下，是否支持幂等！</code></p><h5 id="问题发散"><a href="#问题发散" class="headerlink" title="问题发散"></a><a href="#问题发散" title="问题发散"></a>问题发散</h5><p>消息发送成功，缓存设置失败怎么办？如果对程序要求非常严格，必须有更好的解决方案才行！比如金融电商业务。</p><h3 id="继续学习"><a href="#继续学习" class="headerlink" title="继续学习"></a><a href="#继续学习" title="继续学习"></a>继续学习</h3><p><a href="http://note.youdao.com/" target="_blank" rel="noopener">http://www.i3geek.com/archives/841</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在编程中，可能经常会听到幂等这个词，第一次是年初红包技术复盘时听到了这个词，这次是因为写脚本时被质疑，是否支持幂等。这里总结一下，也算是个记录吧。其实在编程中，很多时候都需要支持幂等，有的程序自然存在幂等，有的需要我们控制。比如与支付相关的场景，比如我们常见的HTTP方法。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="https://upeng.github.io/categories/Thinking/"/>
    
    
      <category term="idempotence" scheme="https://upeng.github.io/tags/idempotence/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制原理理解与实践</title>
    <link href="https://upeng.github.io/2016/12/05/mysql-master-slave/"/>
    <id>https://upeng.github.io/2016/12/05/mysql-master-slave/</id>
    <published>2016-12-05T14:40:03.000Z</published>
    <updated>2022-11-07T03:13:42.754Z</updated>
    
    <content type="html"><![CDATA[<p>只从最简单的mysql主从复制原理与实践着手，之前看到Yshiba老师讲解的挺细致透彻，顺便做下笔记并实践一下。</p><h2 id="主从复制原理-replication"><a href="#主从复制原理-replication" class="headerlink" title="主从复制原理 replication"></a><a href="#主从复制原理-replication" title="主从复制原理 replication"></a>主从复制原理 replication</h2><p>主服务器(master)的binlog,记录master的各种操作（insert、update、delete），master的磁盘只要发生变化就会记录到自己的binlog里面。</p><p>从服务器（slave）如果能读取到master的binlog,那么就可以将master的所做操作跟着执行一遍。但是由于master的binlog中含有master的一些信息，所以需要对binlog进行分析加工，slave的relaylog就是干这种事的，实际上slave将使用relaylog终极日志上的sql操作，保证主从数据一致性。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/mysql-master-slave.gif" alt="mysql-master-slave"><br><a id="more"></a><br><strong>总结</strong>：</p><ol><li>master要配置binlog</li><li>slave要配置relaylog</li><li>master需要grant slave账号使得slave有权读取master的binlog</li><li>slave使用账号连接master</li></ol><h2 id="主从配置过程"><a href="#主从配置过程" class="headerlink" title="主从配置过程"></a><a href="#主从配置过程" title="主从配置过程"></a>主从配置过程</h2><h3 id="编辑master的配置文件my-cnf"><a href="#编辑master的配置文件my-cnf" class="headerlink" title="编辑master的配置文件my.cnf"></a><a href="#编辑master的配置文件my-cnf" title="编辑master的配置文件my.cnf"></a>编辑master的配置文件my.cnf</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.配置server-id</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开启二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.指定二进制日志格式</span></span><br><span class="line"><span class="attr">binlog-format</span>=mixed</span><br></pre></td></tr></table></figure><blockquote><p>二进制日志格式binlog-format</p></blockquote><ol><li>statement：二进制记录的是执行语句，update insert…</li><li>row：二进制执行的是磁盘变化</li><li>mixed：混合的，由系统根据语句决定</li></ol><blockquote><p>到底使用哪种format，根据实际情况判断</p></blockquote><p><strong>比如：</strong><br>磁盘变化少，语句长，使用row<br><code>update user set age = age + 1 where id = 2;</code><br>磁盘变化多，语句短，使用statement<br><code>update slary = slary + 1000;</code> (10w条数据)</p><h3 id="编辑slave的配置文件my-cnf"><a href="#编辑slave的配置文件my-cnf" class="headerlink" title="编辑slave的配置文件my.cnf"></a><a href="#编辑slave的配置文件my-cnf" title="编辑slave的配置文件my.cnf"></a>编辑slave的配置文件my.cnf</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.配置server-id</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开启二进制日志(备份)</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建relay日志</span></span><br><span class="line"><span class="attr">relay-log</span>=mysql-relay</span><br></pre></td></tr></table></figure><blockquote><p>配置完成后重启两个机器的mysql服务器<br><code>service mysqld restart</code></p></blockquote><h2 id="启动主从建立关系"><a href="#启动主从建立关系" class="headerlink" title="启动主从建立关系"></a><a href="#启动主从建立关系" title="启动主从建立关系"></a>启动主从建立关系</h2><h3 id="master的操作"><a href="#master的操作" class="headerlink" title="master的操作"></a><a href="#master的操作" title="master的操作"></a>master的操作</h3><p>查看主服务器的状态<br><code>show master status</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#授权账号密码</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> clinet,<span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="keyword">test</span>@<span class="string">'192.168.1.%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123qwe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure><h3 id="slave的操作"><a href="#slave的操作" class="headerlink" title="slave的操作"></a><a href="#slave的操作" title="slave的操作"></a>slave的操作</h3><p>建立连接</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span></span><br><span class="line"><span class="attribute">master_host</span>=<span class="string">'192.168.1.101'</span></span><br><span class="line"><span class="attribute">master_user</span>=<span class="string">'test'</span></span><br><span class="line"><span class="attribute">master_password</span>=<span class="string">'123qwe'</span></span><br><span class="line"><span class="attribute">master_log_file</span>=<span class="string">'mysql-bin.000001'</span></span><br><span class="line"><span class="attribute">master_log_pass</span>=348</span><br></pre></td></tr></table></figure><p>查看连接状态<br><code>show slave status</code></p><p>启动从服务器同步进程并查看状态<br><code>start slave</code></p><blockquote><p>如果报错Last_IO_Error: error connect to master ‘<a href="mailto:test@192.168.1.101" target="_blank" rel="noopener">test@192.168.1.101</a>:3306’ ……<br>使用Telnet 192.168.1.101 3306排查连接master是否成功<br>有可能是防火墙开了，关闭防火墙：<code>services iptables stop</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a><a href="#验证测试" title="验证测试"></a>验证测试</h3><p>在mater中创建数据库和表，并做各种增删改操作，到从库观察验证</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><a href="#补充说明" title="补充说明"></a>补充说明</h2><p><strong>mysql经常报错如下：</strong><br><code>can&#39;t connect to local mysql server through socket &#39;/tmp/mysqld.sock&#39;</code><br>通过<code>/tmp/mysqld.sock</code>下的socket文件连接不成功，比如我们默认安装的mysql通过配置文件可以发现mysql.sock在<code>/var/lib/mysql/mysql.sock</code>下。也就是说/tmp/下没有mysqld.sock文件</p><p><strong>有两种解决方法：</strong></p><ol><li>指定sock文件位置<br><code>mysql -uroot -p -S /var/lib/mysql/mysql.sock</code></li><li>建立一个软连接<br><code>ln -s /var/lib/mysql/mysql.sock /tmp/mysqld.sock</code></li></ol><h2 id="后续学习计划"><a href="#后续学习计划" class="headerlink" title="后续学习计划"></a><a href="#后续学习计划" title="后续学习计划"></a>后续学习计划</h2><p>主从复制可能会出现的问题级解决方案<br>mysql读写分离策略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;只从最简单的mysql主从复制原理与实践着手，之前看到Yshiba老师讲解的挺细致透彻，顺便做下笔记并实践一下。&lt;/p&gt;
&lt;h2 id=&quot;主从复制原理-replication&quot;&gt;&lt;a href=&quot;#主从复制原理-replication&quot; class=&quot;headerlink&quot; title=&quot;主从复制原理 replication&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#主从复制原理-replication&quot; title=&quot;主从复制原理 replication&quot;&gt;&lt;/a&gt;主从复制原理 replication&lt;/h2&gt;&lt;p&gt;主服务器(master)的binlog,记录master的各种操作（insert、update、delete），master的磁盘只要发生变化就会记录到自己的binlog里面。&lt;/p&gt;
&lt;p&gt;从服务器（slave）如果能读取到master的binlog,那么就可以将master的所做操作跟着执行一遍。但是由于master的binlog中含有master的一些信息，所以需要对binlog进行分析加工，slave的relaylog就是干这种事的，实际上slave将使用relaylog终极日志上的sql操作，保证主从数据一致性。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/mysql-master-slave.gif&quot; alt=&quot;mysql-master-slave&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://upeng.github.io/categories/MySQL/"/>
    
    
      <category term="mysql" scheme="https://upeng.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的终端和命令行item2和zsh</title>
    <link href="https://upeng.github.io/2016/12/04/zsh-and-item2/"/>
    <id>https://upeng.github.io/2016/12/04/zsh-and-item2/</id>
    <published>2016-12-04T15:19:50.000Z</published>
    <updated>2022-11-07T03:13:42.762Z</updated>
    
    <content type="html"><![CDATA[<p>关于zsh和item2的关系可以理解为，zsh就是linux下bash shell的升级版；iterm2是termainal的升级版，可以自定义terminal主题配色；<code>cmd + ,</code>呼出配置。可以新增配置，并将之设置默认，（默认配置前有个⭐）<br><a id="more"></a></p><h3 id="zsh的高效命令（常用）"><a href="#zsh的高效命令（常用）" class="headerlink" title="zsh的高效命令（常用）"></a><a href="#zsh的高效命令（常用）" title="zsh的高效命令（常用）"></a>zsh的高效命令（常用）</h3><ol><li><p>zsh 的命令<strong>补全</strong>功能非常强大，可以补齐路径，补齐命令，补齐参数等。你记住 tar 的所有参数了吗 ，只要 tar -加 tab 键</p></li><li><p>按下 tab 键显示出所有待选项后，再按一次 tab 键，即进入选择模式.进入选择模式后，按 tab 切向下一个选项，按 <code>shift+tab</code> 键切向上一个选项，<code>ctrl+f/b/n/p</code>可以向前后左右切换</p></li><li><p><code>ps aux | grep xxx</code>查进程的 PID，然后kill PID有了 zsh，直接kill xxx然后按下 tab 键即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> emac</span><br><span class="line"><span class="comment"># 按下 tab，变成：</span></span><br><span class="line"><span class="built_in">kill</span> 59683</span><br></pre></td></tr></table></figure></li><li><p>zsh的历史记录跨 session，可以共享。历史记录支持受限查找。比如，输入git，再按向上箭头，会搜索用过的所有 git 命令</p></li><li><p>zsh 的目录跳转更为智能，你无需输入cd，直接输入路径即可。<code>..</code>表示后退一级目录，<code>../../</code>表示后退两级，依次类推。（<code>...</code>的作用和<code>../../</code>相同）</p></li><li><p>输入d回车，将列出当前 session 访问过的所有目录，再输入提示的数字即可进入相应目录。</p></li></ol><h3 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a><a href="#zsh配置" title="zsh配置"></a>zsh配置</h3><p>位于 ~/.zshrc，可以修改theme,当前使用cloud,可以自定义alias</p><h3 id="iterm2的配置"><a href="#iterm2的配置" class="headerlink" title="iterm2的配置"></a><a href="#iterm2的配置" title="iterm2的配置"></a>iterm2的配置</h3><p>color配色方案：colors import我们githubs主题即可，更多关于iterm的信息见<br><a href="https://item2.com。" target="_blank" rel="noopener">https://item2.com。</a><br>比如选择dracula配色方案<br><a href="https://github.com/dracula/iterm" target="_blank" rel="noopener">https://github.com/dracula/iterm</a></p><blockquote><p><code>working directory：Reuse previous&#39;directory</code> //directory总是展示当前dirname</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于zsh和item2的关系可以理解为，zsh就是linux下bash shell的升级版；iterm2是termainal的升级版，可以自定义terminal主题配色；&lt;code&gt;cmd + ,&lt;/code&gt;呼出配置。可以新增配置，并将之设置默认，（默认配置前有个⭐）&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="https://upeng.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="item" scheme="https://upeng.github.io/tags/item/"/>
    
      <category term="zsh" scheme="https://upeng.github.io/tags/zsh/"/>
    
      <category term="mac" scheme="https://upeng.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>经常使用到的几个命令行linux&amp;php</title>
    <link href="https://upeng.github.io/2016/11/13/linux-php-command/"/>
    <id>https://upeng.github.io/2016/11/13/linux-php-command/</id>
    <published>2016-11-13T15:24:35.000Z</published>
    <updated>2022-11-07T03:13:42.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nc命令使用方法"><a href="#nc命令使用方法" class="headerlink" title="nc命令使用方法"></a><a href="#nc命令使用方法" title="nc命令使用方法"></a>nc命令使用方法</h3><p>同一局域网（公司内网）下经常会进行文件的传输，使用<code>nc</code>命令非常方便。</p><p>A向B发送文件，A端命令<br>A@localhost:~ nc B的ip 约定端口 &lt; 传输文件名<br>B端命令，先处于listen状态<br>B@localhost:~ nc -l 约定端口 &gt; 传输文件名</p><p>example</p><a id="more"></a><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">机器A</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"><span class="string">机器B</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br><span class="line"></span><br><span class="line"><span class="string">机器A发送文件（test.txt）到机器B</span></span><br><span class="line"><span class="string">A@localhost:~</span> <span class="string">nc</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>  <span class="number">8888</span> <span class="string">&lt;</span> <span class="string">test.txt</span> </span><br><span class="line"></span><br><span class="line"><span class="string">机器B监听8888端口（自定义）</span></span><br><span class="line"><span class="string">B@localhost:~</span> <span class="string">nc</span> <span class="string">-l</span> <span class="number">8888</span> <span class="string">&gt;</span> <span class="string">test.txt</span></span><br></pre></td></tr></table></figure><h3 id="php经常使用到的命令行"><a href="#php经常使用到的命令行" class="headerlink" title="php经常使用到的命令行"></a><a href="#php经常使用到的命令行" title="php经常使用到的命令行"></a>php经常使用到的命令行</h3><ul><li><p>查看php文件是否有语法错误<br><code>php -ln filename.php</code></p></li><li><p>执行php文件<br><code>php filename.php</code><br><code>php -f filename.php</code></p></li><li><p>搜索php.ini关键词信息<br><code>php -i | grep keyword</code></p></li><li><p>查询php.ini位置信息<br><code>php --ini</code></p></li><li><p>查看php扩展模块<br><code>php -m</code></p></li></ul><blockquote><p>上述<code>查询php.ini</code>和<code>检测语法错误</code>很好用，源于查看session配置和运行脚本没有任何输出。</p></blockquote><p>备注：关于git命令，特别是与远程仓库的交互，待整理和总结</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nc命令使用方法&quot;&gt;&lt;a href=&quot;#nc命令使用方法&quot; class=&quot;headerlink&quot; title=&quot;nc命令使用方法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#nc命令使用方法&quot; title=&quot;nc命令使用方法&quot;&gt;&lt;/a&gt;nc命令使用方法&lt;/h3&gt;&lt;p&gt;同一局域网（公司内网）下经常会进行文件的传输，使用&lt;code&gt;nc&lt;/code&gt;命令非常方便。&lt;/p&gt;
&lt;p&gt;A向B发送文件，A端命令&lt;br&gt;A@localhost:~ nc B的ip 约定端口 &amp;lt; 传输文件名&lt;br&gt;B端命令，先处于listen状态&lt;br&gt;B@localhost:~ nc -l 约定端口 &amp;gt; 传输文件名&lt;/p&gt;
&lt;p&gt;example&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="linux" scheme="https://upeng.github.io/tags/linux/"/>
    
      <category term="nc" scheme="https://upeng.github.io/tags/nc/"/>
    
      <category term="php" scheme="https://upeng.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>静态方法和静态成员变量</title>
    <link href="https://upeng.github.io/2016/10/12/static/"/>
    <id>https://upeng.github.io/2016/10/12/static/</id>
    <published>2016-10-12T15:29:13.000Z</published>
    <updated>2022-11-07T03:13:42.759Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>问题来源：</p></blockquote><p>写了一个<code>Model_User</code>，创建了2个静态方法func1和func2，2个静态方法中都含有公共的连接数据库的逻辑，突然想到代码重用，然后创建了构造方法，将连接数据库的逻辑放在<code>__construct()</code>中，然后去调用<code>Model_User</code>的静态方法<br><a id="more"></a></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model_User::fu<span class="symbol">nc1</span><span class="comment">()</span>;</span><br></pre></td></tr></table></figure><p><code>报错：</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating<span class="built_in"> default </span>object <span class="keyword">from</span> empty value。。。</span><br><span class="line">Using <span class="variable">$this</span> when <span class="keyword">not</span> <span class="keyword">in</span> object context <span class="keyword">in</span>。。。。</span><br></pre></td></tr></table></figure><p>因为我们直接使用类调用静态方法的方式，是根本不会走到构造方法的，而构造方法只有在new实例的时候才会调用。同时因为<code>$this</code>本身就是一个instance（实例）而我们根本就没有new 对象，所以。。。</p><p><strong>注意</strong></p><ol><li>如果使用类调用静态方法的形式，那么要注意<code>__construct</code>里面的操作就over了，因为<code>__construct</code>不会调用；</li><li>不能在静态方法中使用<code>$this</code>去调用普通成员变量和成员函数，因为你没有实例化对象，而$this就是一个instance;就算这样也是不可行的</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$obj</span> = new Model_User</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$obj</span>-&gt;func1();</span></span><br></pre></td></tr></table></figure><blockquote><p>正常情况下，静态方法中是不能调用非静态成员变量或非静态方法的！</p></blockquote><p>静态成员变量和静态方法存储在堆中(一个公共的池子)。<br>所有实例化的对象instance都可以使用和操作它。<br>举例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> $b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$a = $num; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;b = $num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>(<span class="keyword">self</span>::$a, <span class="keyword">$this</span>-&gt;b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$apple1 = <span class="keyword">new</span> Apple();</span><br><span class="line">$apple1-&gt;set(<span class="number">2</span>);</span><br><span class="line">$res1 = $apple1-&gt;get();</span><br><span class="line"></span><br><span class="line">$apple2 = <span class="keyword">new</span> Apple();</span><br><span class="line">$res2 = $apple2-&gt;get();</span><br><span class="line"></span><br><span class="line">print_r($res1);  <span class="comment">//array(2,2)</span></span><br><span class="line">print_r($res2);  <span class="comment">//array(2,1)</span></span><br></pre></td></tr></table></figure><p>很明显，静态成员变量和普通成员变量的区别；在实际应用场景中，需要合理使用</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;问题来源：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;写了一个&lt;code&gt;Model_User&lt;/code&gt;，创建了2个静态方法func1和func2，2个静态方法中都含有公共的连接数据库的逻辑，突然想到代码重用，然后创建了构造方法，将连接数据库的逻辑放在&lt;code&gt;__construct()&lt;/code&gt;中，然后去调用&lt;code&gt;Model_User&lt;/code&gt;的静态方法&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="static" scheme="https://upeng.github.io/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>从编写到发布laravel扩展</title>
    <link href="https://upeng.github.io/2016/10/11/publish-laravel-package/"/>
    <id>https://upeng.github.io/2016/10/11/publish-laravel-package/</id>
    <published>2016-10-11T15:08:11.000Z</published>
    <updated>2022-11-07T03:13:42.758Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a><a href="#工具准备" title="工具准备"></a>工具准备</h3><blockquote><p>创建开源项目三工具github、packageist、composer</p></blockquote><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">github:</span> git仓库，是用于存放源代码的地方</span><br><span class="line"><span class="symbol">packagist:</span> 用于发布github上的扩展程序或者项目</span><br><span class="line"><span class="symbol">composer:</span> 用于使用代码的工具</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>github-&gt;packagist-&gt;composer</code></p><ol><li>怎样写一个laravel扩展，发布到packagist，提供composer方法</li><li>git命令熟悉</li></ol><h3 id="写laravel扩展"><a href="#写laravel扩展" class="headerlink" title="写laravel扩展"></a><a href="#写laravel扩展" title="写laravel扩展"></a>写laravel扩展</h3><h4 id="本地编写"><a href="#本地编写" class="headerlink" title="本地编写"></a><a href="#本地编写" title="本地编写"></a>本地编写</h4><p>本地编写package，完成后，在laravel根目录下的composer.json中添加一行<br><code>&quot;Upstriving\\Curd\\&quot;: &quot;package/upstriving/curd/src&quot;</code></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"autoload"</span>: &#123;</span><br><span class="line">       <span class="string">"classmap"</span>: [</span><br><span class="line">           <span class="string">"database"</span></span><br><span class="line">       ],</span><br><span class="line">       <span class="string">"psr-4"</span>: &#123;</span><br><span class="line">           <span class="string">"App\\"</span>: <span class="string">"app/"</span>,</span><br><span class="line">           <span class="string">"Upstriving\\Curd\\"</span>: <span class="string">"package/upstriving/curd/src"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>添加之后<code>composer dump-autoload</code>将之加到路由中<br><code>php artisan tinker</code>测试</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; app('sqladmin')</span><br><span class="line">=&gt; Upstriving\Curd\SQLAdmin &#123;#<span class="number">629</span>&#125;</span><br><span class="line">&gt;&gt;&gt; app('sqladmin')-&gt;makeSelect('user','id,name',['id'=&gt;<span class="number">2</span>]);</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="string">"sql"</span> =&gt; <span class="string">"select id,name from user where id=?"</span>,</span><br><span class="line">     <span class="string">"data"</span> =&gt; [</span><br><span class="line">       <span class="number">2</span>,</span><br><span class="line">     ],</span><br><span class="line">   ]</span><br><span class="line">&gt;&gt;&gt; app('sqladmin')-&gt;makeDelete('user',['name'=&gt;'upfriend'])</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="string">"sql"</span> =&gt; <span class="string">"delete from user where `name`=?"</span>,</span><br><span class="line">     <span class="string">"data"</span> =&gt; [</span><br><span class="line">       <span class="string">"upfriend"</span>,</span><br><span class="line">     ],</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><h4 id="生成composer-json"><a href="#生成composer-json" class="headerlink" title="生成composer.json"></a><a href="#生成composer-json" title="生成composer.json"></a>生成composer.json</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">composer init</span><br><span class="line">This command will guide you through creating your composer.json config.</span><br><span class="line"></span><br><span class="line">Package name (&lt;vendor&gt;/&lt;name&gt;) [yupeng6/curd]: upstriving/curd</span><br><span class="line">Description []: assemble sql statements quickly</span><br><span class="line">Author [upeng &lt;825415473@qq.com&gt;, n <span class="keyword">to</span> skip]:</span><br><span class="line">Minimum Stability []: dev</span><br><span class="line">Package<span class="built_in"> Type </span>(e.g. library, project, metapackage, composer-plugin) []:</span><br><span class="line">License []: MIT</span><br><span class="line"></span><br><span class="line">Define your dependencies.</span><br><span class="line"></span><br><span class="line">Would you like <span class="keyword">to</span> define your dependencies (require) interactively [<span class="literal">yes</span>]? <span class="literal">no</span></span><br><span class="line">Would you like <span class="keyword">to</span> define your dev dependencies (require-dev) interactively [<span class="literal">yes</span>]? <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"upstriving/curd"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"assemble sql statements quickly"</span>,</span><br><span class="line">    <span class="string">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">    <span class="string">"authors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"upeng"</span>,</span><br><span class="line">            <span class="string">"email"</span>: <span class="string">"825415473@qq.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"minimum-stability"</span>: <span class="string">"dev"</span>,</span><br><span class="line">    <span class="string">"require"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you confirm generation [<span class="literal">yes</span>]? <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h4 id="生成composer-json-1"><a href="#生成composer-json-1" class="headerlink" title="生成composer.json"></a><a href="#生成composer-json-1" title="生成composer.json"></a>生成composer.json</h4><blockquote><p>添加autoload</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="string">"autoload"</span>: &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="string">"psr-4"</span>: &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">          <span class="string">"Upstriving\\Curd\\"</span>: <span class="string">"src/"</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a><a href="#推送到github" title="推送到github"></a>推送到github</h4><blockquote><p>当前扩展目录下执行</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="symbol">'add</span> <span class="keyword">new</span> <span class="keyword">package</span>'</span><br></pre></td></tr></table></figure><p>github手动创建一个<code>repository(laravel-sqladmin)</code><br>在本地目录下，复制两行命令并执行，将本地代码推送到github</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> remote <span class="keyword">add </span>origin git<span class="comment">@github.com:upeng/laravel-sqladmin.git</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>-u origin master</span><br></pre></td></tr></table></figure><p>新增readme.md</p><h4 id="通过github的package服务发布到packagist中"><a href="#通过github的package服务发布到packagist中" class="headerlink" title="通过github的package服务发布到packagist中"></a><a href="#通过github的package服务发布到packagist中" title="通过github的package服务发布到packagist中"></a>通过github的package服务发布到packagist中</h4><p>供其他开发者通过composer使用<br>登录<code>https://packagist.org/</code>,<br><img src="http://ww2.sinaimg.cn/mw690/006iFiRLjw1f8o4ehp6l9j31c30kejve.jpg" alt="此处输入图片的描述"><br>拿到token值，回到<code>github/larvavel-sqladmin/settings/integrations &amp; service</code><br>执行<code>add service/packagist</code><br><img src="http://ww2.sinaimg.cn/mw690/006iFiRLjw1f8o4eibz58j31j50u9gsy.jpg" alt="此处输入图片的描述"><br>输入用户名user和token(从packagist中获取)<br>成功之后如下<br><img src="http://ww3.sinaimg.cn/mw690/006iFiRLjw1f8o4eizjdvj31k70ra7bl.jpg" alt="此处输入图片的描述"></p><p>再次回到packagist中，submit刚才那个repository地址<br><img src="http://ww3.sinaimg.cn/mw690/006iFiRLjw1f8o4ejjp7zj30wk0d8jsx.jpg" alt="此处输入图片的描述"><br><img src="http://ww2.sinaimg.cn/mw690/006iFiRLjw1f8o4ek6aagj30wp0epmzr.jpg" alt="此处输入图片的描述"><br><img src="http://ww1.sinaimg.cn/mw690/006iFiRLjw1f8o4ektd7qj318o0hg77p.jpg" alt="此处输入图片的描述"></p><p>提示这个package is not auto_updated，需要到github中设置一下<br>github/larvavel-sqladmin/settings/integrations &amp; service/packagist<br>点击test service，<br><img src="http://ww3.sinaimg.cn/mw690/006iFiRLjw1f8o4elc6eej31600q6wiv.jpg" alt="此处输入图片的描述"></p><p>如果显示<br><code>Okay, the test payload is on its way.</code><br>说明自动更新没有问题，再次回到packagist发现刚刚的提示已经不见了<br><img src="http://ww3.sinaimg.cn/mw690/006iFiRLjw1f8o4em26svj30n10d5myx.jpg" alt="此处输入图片的描述"></p><h4 id="修改或新增文件，观察是否实时更新到packagist"><a href="#修改或新增文件，观察是否实时更新到packagist" class="headerlink" title="修改或新增文件，观察是否实时更新到packagist"></a><a href="#修改或新增文件，观察是否实时更新到packagist" title="修改或新增文件，观察是否实时更新到packagist"></a>修改或新增文件，观察是否实时更新到packagist</h4><blockquote><p>新增readme.file</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git commit -m <span class="string">''</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>增加版本号</p></blockquote><p><code>git tag 1.0 -a</code><br>输入: release version 1.0<br><code>git push --tags</code><br>发现github上多了一个版本号,packagist版本也随之更新<br><img src="http://ww3.sinaimg.cn/mw690/006iFiRLjw1f8o4emqsblj312x0nv446.jpg" alt="此处输入图片的描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#工具准备&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;创建开源项目三工具github、packageist、composer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight avrasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;github:&lt;/span&gt; git仓库，是用于存放源代码的地方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;packagist:&lt;/span&gt; 用于发布github上的扩展程序或者项目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;composer:&lt;/span&gt; 用于使用代码的工具&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="laravel" scheme="https://upeng.github.io/tags/laravel/"/>
    
      <category term="composer" scheme="https://upeng.github.io/tags/composer/"/>
    
      <category term="packageist" scheme="https://upeng.github.io/tags/packageist/"/>
    
  </entry>
  
  <entry>
    <title>vim学习笔记</title>
    <link href="https://upeng.github.io/2016/09/11/vim/"/>
    <id>https://upeng.github.io/2016/09/11/vim/</id>
    <published>2016-09-11T15:05:25.000Z</published>
    <updated>2022-11-07T03:13:42.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>还是要经常折腾一下</p></blockquote><p>最近稍微折腾了一下vim，大家都知道linux环境下如果vim操作的足够熟练，完全可以替代各种文本编辑器，然而自己对vim的操作仍停留在最原始和基础的命令，只会简单的增删改查，比如删除d，进入编辑模式i，复制粘贴y&amp;p，代码上下翻阅左右箭头，看到这你估计都惊呆了，怎么这么low!也是由于近期经常需要到仿真机上修改代码，发现自己vim编辑效率超级低，这才想着好好过一遍vim指令，提高逼格！^_^</p><h3 id="vim配置文件-vimrc"><a href="#vim配置文件-vimrc" class="headerlink" title="vim配置文件.vimrc"></a><a href="#vim配置文件-vimrc" title="vim配置文件.vimrc"></a>vim配置文件.vimrc</h3><p>这个文件是vim的配置文件，在这里配置一下全局生效，更加丰富的配置后续逐步学习</p><ol><li>比如之前每次查代码行数都要 <code>:set nu</code>，如果写在.vimrc就不用每次都<code>:set nu</code>了。</li><li>比如写完一行代码enter换行后，又从头再来，必须手动tab缩进。。。</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="built_in">number</span> <span class="comment"># 显示行号</span></span><br><span class="line"><span class="keyword">set</span> autoindent <span class="comment"># 自动缩进</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a><a href="#vim模式" title="vim模式"></a>vim模式</h3><p>我们知道vim的模式【insert模式、普通模式、visual模式】中<strong>insert模式</strong>和<strong>visual模式</strong>是不能直接互跳的，必须先返回到<strong>普通模式</strong>！普通模式下<code>:</code>进入命令模式<br>快速进入insert模式：普通模式下输入 i/o/a，esc返回到普通模式<br>快速进入visual模式：普通模式下输入 v，再次v返回到普通模式</p><h3 id="普通模式下快速跳转"><a href="#普通模式下快速跳转" class="headerlink" title="普通模式下快速跳转"></a><a href="#普通模式下快速跳转" title="普通模式下快速跳转"></a>普通模式下快速跳转</h3><p>不要只会箭头上下左右了！这个能提高效率</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gg(<span class="number">1</span>G)  <span class="comment"># 文件顶部 </span></span><br><span class="line">G     <span class="comment"># 文件尾部</span></span><br><span class="line">control + [    <span class="comment"># 向上片段移动</span></span><br><span class="line">control + ] <span class="comment"># 向下片段移动 </span></span><br><span class="line"><span class="keyword">j </span><span class="comment"># 下一行</span></span><br><span class="line">k <span class="comment"># 上一行</span></span><br><span class="line">w <span class="comment"># 下一个单词</span></span><br><span class="line"><span class="keyword">b </span><span class="comment"># 上一个单词</span></span><br></pre></td></tr></table></figure><h3 id="复制粘贴一块代码"><a href="#复制粘贴一块代码" class="headerlink" title="复制粘贴一块代码"></a><a href="#复制粘贴一块代码" title="复制粘贴一块代码"></a>复制粘贴一块代码</h3><ol><li>按Esc切换到正常模式；</li><li>把光标移到你需要复制的代码行首；</li><li>按V选择整行，可移动光标选择多行；</li><li>按d剪切或按y复制选择的代码；</li><li>移动光标到你需要粘贴的位置，按p粘贴代码到光标后的位置，或按P粘贴到光标前。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a><a href="#删除" title="删除"></a>删除</h3><blockquote><p>下面命令必须先将鼠标移动到指定位置或指定行</p></blockquote><ul><li>字母<code>x</code> 删除当前定位的字母</li><li><code>dw</code> 删除当前鼠标所在的单词 <code>db</code>向前删除一个单词</li><li><code>5dd</code>删除从当前行开始（包括当前行在内）的5行</li><li><code>dG</code> 输入<code>d</code>，然后<code>shift+g</code>(或大写<code>G</code>)</li><li>删除21-94行之间的内容，鼠标在第10行，如何快速删除！记住！总是忘记！<code>:21,94d</code></li></ul><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><a href="#命令模式" title="命令模式"></a>命令模式</h3><p>普通模式下<code>/</code>搜索，n下一个，N上一个<br>普通模式下<code>:e filepath/file</code>打开file<br>批量替换<code>:%s/word1/word2/g</code><br>复制一个文件全部内容到当前文件的指定位置<code>:read filepath/file</code></p><h3 id="撤销或重做"><a href="#撤销或重做" class="headerlink" title="撤销或重做"></a><a href="#撤销或重做" title="撤销或重做"></a>撤销或重做</h3><p><code>u</code>撤销，<code>ctrl+r</code>重做（像sublime的cmd+y）</p><h3 id="快速进入insert模式"><a href="#快速进入insert模式" class="headerlink" title="快速进入insert模式"></a><a href="#快速进入insert模式" title="快速进入insert模式"></a>快速进入insert模式</h3><p>普通模式下，随处都可以进入编辑模式，可能之前你只注意到<code>i</code>命令，其实还有两个<strong>非常实用</strong>的命令<code>a</code>和<code>o</code><br><code>a</code>–从当前鼠标定位开始,立刻可编辑<br><code>o</code>–立刻换行编辑</p><h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a><a href="#代码注释" title="代码注释"></a>代码注释</h3><blockquote><p>代码注释：</p></blockquote><ul><li>按v切换到可视化模式；</li><li>移动光标(j或k)选中需要注释的行的开头；</li><li>按大写I，然后输入注释符，如#；</li><li>最后按Esc。</li></ul><blockquote><p>取消注释：</p></blockquote><ul><li>按Ctrl+v切换到可视化模式；</li><li>按j或k选择要删除的注释符；</li><li>按d或x删除注释符</li></ul><p>通过学习，效率有所提高，但vim更加丰富的功能还需要进一步探索，计划上面的命令使用非常熟练自如后再进行第二阶段的学习和探索–命令模式和目录可视化的打造。</p><h3 id="vim键盘图"><a href="#vim键盘图" class="headerlink" title="vim键盘图"></a><a href="#vim键盘图" title="vim键盘图"></a>vim键盘图</h3><p><img src="https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/vim-keyboard.png" alt="vim-keyboard"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><a href="#参考文章" title="参考文章"></a>参考文章</h3><p><a href="https://www.shiyanlou.com/questions/3176" target="_blank" rel="noopener">https://www.shiyanlou.com/questions/3176</a><br><a href="http://harttle.com/2015/11/07/vim-cursor.html" target="_blank" rel="noopener">http://harttle.com/2015/11/07/vim-cursor.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;还是要经常折腾一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近稍微折腾了一下vim，大家都知道linux环境下如果vim操作的足够熟练，完全可以替代各种文本编辑器，然而自己对vim的操作仍停留在最原始和基础的命令，只会简单的增删改查，比如删除d，进入编辑模式i，复制粘贴y&amp;amp;p，代码上下翻阅左右箭头，看到这你估计都惊呆了，怎么这么low!也是由于近期经常需要到仿真机上修改代码，发现自己vim编辑效率超级低，这才想着好好过一遍vim指令，提高逼格！^_^&lt;/p&gt;
&lt;h3 id=&quot;vim配置文件-vimrc&quot;&gt;&lt;a href=&quot;#vim配置文件-vimrc&quot; class=&quot;headerlink&quot; title=&quot;vim配置文件.vimrc&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#vim配置文件-vimrc&quot; title=&quot;vim配置文件.vimrc&quot;&gt;&lt;/a&gt;vim配置文件.vimrc&lt;/h3&gt;&lt;p&gt;这个文件是vim的配置文件，在这里配置一下全局生效，更加丰富的配置后续逐步学习&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比如之前每次查代码行数都要 &lt;code&gt;:set nu&lt;/code&gt;，如果写在.vimrc就不用每次都&lt;code&gt;:set nu&lt;/code&gt;了。&lt;/li&gt;
&lt;li&gt;比如写完一行代码enter换行后，又从头再来，必须手动tab缩进。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 显示行号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; autoindent &lt;span class=&quot;comment&quot;&gt;# 自动缩进&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://upeng.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://upeng.github.io/tags/linux/"/>
    
      <category term="vim" scheme="https://upeng.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装LNMP(Nginx+PHP5.6)环境</title>
    <link href="https://upeng.github.io/2016/08/28/mac-lnmp/"/>
    <id>https://upeng.github.io/2016/08/28/mac-lnmp/</id>
    <published>2016-08-28T14:28:49.000Z</published>
    <updated>2022-11-07T03:13:42.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><p>从零开始安装Mac下LNMP环境的过程</p><blockquote><p>确保系统已经安装xcode，然后使用一行命令安装依赖管理工具Homebrew</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/<span class="keyword">install</span>/<span class="keyword">master</span>/<span class="keyword">install</span>)<span class="string">"</span></span><br></pre></td></tr></table></figure><p>之后就可以使用<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>FORMULA</span><br></pre></td></tr></table></figure></p><p>来安装所需要的依赖了.更详细的信息参考Homebrew的[官方Cookbook][1]</p><p>因此使用Homebrew常见的流程是：</p><ol><li>增加一个程序源（新增一个水龙头） brew tap homebrew/php</li><li>更新程序源 brew update</li><li>安装程序包（按照配方酿酒） brew install git</li><li>查看配置 brew config 可以看到程序包默认安装在/usr/local/Cellar下 （酒桶放在地窖内）<a id="more"></a><h2 id="安装PHP5-6（FPM方式）"><a href="#安装PHP5-6（FPM方式）" class="headerlink" title="安装PHP5.6（FPM方式）"></a>安装PHP5.6（FPM方式）</h2>首先加入Homebrew官方的几个软件源<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>tap homebrew/dupes</span><br><span class="line"><span class="keyword">brew </span>tap homebrew/versions</span><br><span class="line"><span class="keyword">brew </span>tap homebrew/php</span><br></pre></td></tr></table></figure></li></ol><p>PHP如果采用默认配置安装，会编译mod_php模块并只运行在Apache环境下，为了使用Nginx，这里需要编译php-fpm并且禁用apache，主要通过参数<code>--without-fpm --without-apache</code>来实现。完整的安装指令为<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">brew install php56 <span class="string">\</span></span><br><span class="line">--without-snmp <span class="string">\</span></span><br><span class="line">--without-apache <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-debug <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-fpm <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-intl <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-homebrew-curl <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-homebrew-libxslt <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-homebrew-openssl <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-imap <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-mysql <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-tidy</span><br></pre></td></tr></table></figure></p><p>由于OSX已经自带了PHP5.5环境，因此需要修改系统路径，优先运行brew安装的版本，在<code>~/.bashrc</code>里加入：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"/usr/local/bin:/usr/local/sbin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure></p><blockquote><p>这时运行 php -v查看版本是否是5.6<br>运行php -m 查看PHP安装都扩展列表</p></blockquote><p>如果要安装新的php扩展，可以直接安装而不用每次重新编译php，所有的扩展可以通过<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>search php56</span><br></pre></td></tr></table></figure></p><p>看到，下面是我自己所需要的扩展，可以支持Phalcon框架：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install php56-gearman php56-msgpack php56-memcache php56-memcached php56-mongo  php56-phalcon php56-redis php56-xdebug</span><br></pre></td></tr></table></figure></p><h3 id="PHP-FPM的加载与启动"><a href="#PHP-FPM的加载与启动" class="headerlink" title="PHP-FPM的加载与启动"></a>PHP-FPM的加载与启动</h3><p>php-fpm.conf  php.ini<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>php<span class="regexp">/5.6</span></span><br></pre></td></tr></table></figure></p><p>php-fpm进程<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="keyword">local</span>/sbin</span><br></pre></td></tr></table></figure></p><p><strong>安装完毕后可以通过以下指令启动和停止php-fpm</strong><br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./php-fpm</span> -D    <span class="string">//</span>进入sbin目录</span><br><span class="line"></span><br><span class="line">killall php-fpm</span><br></pre></td></tr></table></figure></p><p>同时可以将php-fpm加入开机启动<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv <span class="string">/usr/local/opt/php56/</span>*<span class="string">.plist</span> ~<span class="string">/Library/LaunchAgents</span></span><br><span class="line"></span><br><span class="line">launchctl load ~<span class="string">/Library/LaunchAgents/homebrew.mxcl.php56.plist</span></span><br></pre></td></tr></table></figure></p><h3 id="查看php-fpm进程"><a href="#查看php-fpm进程" class="headerlink" title="查看php-fpm进程"></a>查看php-fpm进程</h3><p>查看9000端口<br><code>lsof -i:9000</code><br>或者<br><code>ps -ef | grep php-fpm</code></p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>nginx</span><br></pre></td></tr></table></figure><p>安装完毕后可以通过<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">nginx -<span class="keyword">s</span> <span class="keyword">quit</span></span><br></pre></td></tr></table></figure></p><p>启动和关闭，同时也支持重载配置文件等操作<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload|<span class="type">reopen</span>|<span class="type">stop</span>|<span class="type">quit</span></span><br></pre></td></tr></table></figure></p><p>nginx安装后默认监听8080端口，可以访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 查看状态。如果要想监听80端口需要root权限，运行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chown <span class="string">root:</span>wheel <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>nginx<span class="regexp">/1.6.2/</span>bin/nginx</span><br><span class="line">sudo chmod u+s <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>nginx<span class="regexp">/1.6.2/</span>bin/nginx</span><br></pre></td></tr></table></figure><blockquote><p>我是直接在nginx配置中改成80端口，然后重启生效<br>并使用root权限启动</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo nginx</span></span><br></pre></td></tr></table></figure><p>开机启动<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv <span class="string">/usr/local/opt/nginx/</span>*<span class="string">.plist</span> ~<span class="string">/Library/LaunchAgents</span></span><br><span class="line"></span><br><span class="line">launchctl load ~<span class="string">/Library/LaunchAgents/homebrew.mxcl.nginx.plist</span></span><br></pre></td></tr></table></figure></p><h2 id="Nginx-PHP-FPM配置"><a href="#Nginx-PHP-FPM配置" class="headerlink" title="Nginx + PHP-FPM配置"></a>Nginx + PHP-FPM配置</h2><p>好文：<a href="http://www.nginx.cn/nginx-how-to" target="_blank" rel="noopener">http://www.nginx.cn/nginx-how-to</a></p><p>Nginx一般都会运行多个域名（虚拟主机）</p><blockquote><p>按Ubuntu的文件夹结构来存放Nginx的配置文件</p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/<span class="keyword">var</span>/logs/nginx</span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/etc/nginx/sites-available</span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/etc/nginx/sites-enabled</span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/etc/nginx/<span class="keyword">conf</span>.<span class="keyword">d</span></span><br><span class="line"><span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/etc/nginx/ssl</span><br></pre></td></tr></table></figure><blockquote><p>联想到work中，vhost和fpm.d目录，新增域名与目录时，只需要增加两个配置文件；前提时php-fpm.conf和nginx.conf主配置文件中都有</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> vhost/<span class="regexp">*.conf</span></span><br><span class="line">include fpm.d/<span class="regexp">*.conf</span></span><br></pre></td></tr></table></figure><p><strong>上述都conf.d等同于fpm.d，sites-enabled等同于vhost</strong></p><h3 id="编辑Nginx全局配置"><a href="#编辑Nginx全局配置" class="headerlink" title="编辑Nginx全局配置"></a>编辑Nginx全局配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>nginx<span class="regexp">/nginx.conf</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span>   /usr/local/var/logs/nginx/error.log <span class="literal">debug</span>;</span><br><span class="line"><span class="attribute">pid</span>        /usr/local/var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$request</span>" <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$http_referer</span>" "<span class="variable">$http_user_agent</span>" '</span></span><br><span class="line">        <span class="string">'"<span class="variable">$http_x_forwarded_for</span>" <span class="variable">$host</span> <span class="variable">$request_time</span> <span class="variable">$upstream_response_time</span> <span class="variable">$scheme</span> '</span></span><br><span class="line">        <span class="string">'<span class="variable">$cookie_evalogin</span>'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /usr/local/var/logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">port_in_redirect</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /usr/local/etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来首先可以把一些可复用配置独立出来放在<code>/usr/local/etc/nginx/conf.d</code>下，比如fastcgi的设置就可以独立出来<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d/</span>php-fpm</span><br></pre></td></tr></table></figure></p><p>内容为<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">try_files</span>                   <span class="variable">$uri</span> = <span class="number">404</span>;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span>                <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">    <span class="attribute">fastcgi_index</span>               index.php;</span><br><span class="line">    <span class="attribute">fastcgi_intercept_errors</span>    <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">include</span> /usr/local/etc/nginx/fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后<code>/usr/local/etc/nginx/sites-enabled</code>目录下可以一个文件对应一个域名的配置，比如web服务器目录是<code>/opt/htdocs</code><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span><span class="keyword">default</span></span><br></pre></td></tr></table></figure></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">root</span>         /opt/htdocs/;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">include</span>     /usr/local/etc/nginx/conf.d/php-fpm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时启动了php-fpm并且启动了Nginx后，就可以通过<a href="http://localhost来运行php程序了" target="_blank" rel="noopener">http://localhost来运行php程序了</a></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>mysql</span><br></pre></td></tr></table></figure><p>可以通过<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql.<span class="built_in">server</span> start</span><br><span class="line">mysql.<span class="built_in">server</span> <span class="keyword">stop</span></span><br></pre></td></tr></table></figure></p><p>来启动／停止，启动后默认应为空密码，可以通过mysqladmin设置一个密码<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysqladmin</span> -uroot password <span class="string">"mypassword"</span></span><br></pre></td></tr></table></figure></p><p>但是在操作的时候出现了空密码无法登入的情况，最终只能通过mysqld_safe来设置<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqld_safe --skip-grant-tables</span><br><span class="line">mysql -u root</span><br><span class="line">mysql&gt; <span class="keyword">UPDATE</span> mysql.<span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">Password</span>=<span class="keyword">PASSWORD</span>(<span class="string">'mypassword'</span>) <span class="keyword">WHERE</span> <span class="keyword">User</span>=<span class="string">'root'</span>;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></p><p><strong>依旧报错</strong></p><blockquote><p><strong>坑1</strong>：一直出现mysql.sock错误，<code>mysql -uroot -p</code>;<br><strong>填坑1</strong>：<code>mysql -h 127.0.0.1 -u root -p</code>  why?</p></blockquote><blockquote><p><strong>坑2</strong>：设置密码报错：<code>Password</code>字段不存在<br><strong>填坑2</strong>：mysql5.7已将<code>Password</code>字段去掉，改成<code>authentication_string</code>；所以正确都姿势如下：<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.<span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="keyword">password</span>(<span class="string">'123qwe'</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>老版本mysql没变</p></blockquote><p>最后将MySQL加入开机启动<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/my</span>sql<span class="regexp">/5.6.22/</span>homebrew.mxcl.mysql.plist ~<span class="regexp">/Library/</span>LaunchAgents<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p><h2 id="查看服务列表"><a href="#查看服务列表" class="headerlink" title="查看服务列表"></a>查看服务列表</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services <span class="built_in">list</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name  Status <span class="built_in"> User </span>   Plist</span><br><span class="line">mysql started root    /Library/LaunchDaemons/homebrew.mxcl.mysql.plist</span><br><span class="line">nginx started yupeng6 /Users/yupeng6/Library/LaunchAgents/homebrew.mxcl.nginx.plist</span><br><span class="line">php56 started yupeng6 /Users/yupeng6/Library/LaunchAgents/homebrew.mxcl.php56.plist</span><br></pre></td></tr></table></figure><p>安装redis和memcache过程省略，详见下面博文，本文也是参考此<br><a href="http://avnpc.com/pages/install-lnmp-on-osx" target="_blank" rel="noopener">http://avnpc.com/pages/install-lnmp-on-osx</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Homebrew&quot;&gt;&lt;a href=&quot;#安装Homebrew&quot; class=&quot;headerlink&quot; title=&quot;安装Homebrew&quot;&gt;&lt;/a&gt;安装Homebrew&lt;/h2&gt;&lt;p&gt;从零开始安装Mac下LNMP环境的过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;确保系统已经安装xcode，然后使用一行命令安装依赖管理工具Homebrew&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/&lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;/&lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后就可以使用&lt;br&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;brew &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;install &lt;/span&gt;FORMULA&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;来安装所需要的依赖了.更详细的信息参考Homebrew的[官方Cookbook][1]&lt;/p&gt;
&lt;p&gt;因此使用Homebrew常见的流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加一个程序源（新增一个水龙头） brew tap homebrew/php&lt;/li&gt;
&lt;li&gt;更新程序源 brew update&lt;/li&gt;
&lt;li&gt;安装程序包（按照配方酿酒） brew install git&lt;/li&gt;
&lt;li&gt;查看配置 brew config 可以看到程序包默认安装在/usr/local/Cellar下 （酒桶放在地窖内）
    
    </summary>
    
      <category term="其他" scheme="https://upeng.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Mac" scheme="https://upeng.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>首次折腾Mac</title>
    <link href="https://upeng.github.io/2016/08/28/mac-primary/"/>
    <id>https://upeng.github.io/2016/08/28/mac-primary/</id>
    <published>2016-08-28T02:09:29.000Z</published>
    <updated>2022-11-07T03:13:42.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li>delete（backspac）</li><li>fn＋delete（后删）</li><li>option＋v ＝ √</li><li>command ＋ space ＝ spotlight</li><li>option ＋ space ＝ hotkey window 呼起item2</li><li>control ＋ space ＝ 输入法切换</li></ul><h3 id="开发配置"><a href="#开发配置" class="headerlink" title="开发配置"></a>开发配置</h3><p>查看<strong>Mac开发配置手册</strong>省了很多时间<br><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/" target="_blank" rel="noopener">https://aaaaaashu.gitbooks.io/mac-dev-setup/content/</a><br>iTem2文档也是相当之多<br><a href="https://leohxj.gitbooks.io/a-programmer-prepares/content/software/mac/softwares/iTerm2.html" target="_blank" rel="noopener">https://leohxj.gitbooks.io/a-programmer-prepares/content/software/mac/softwares/iTerm2.html</a><br><a id="more"></a></p><blockquote><p><strong>坑</strong>：在App Store中安装xcode，总是提示第一次使用，需要输入一堆东西，然而没有什么卵用，浪费了我好多时间。果断去<code>https://developer.apple.com/xcode/</code>下载,下载Xcode command line tools即可，只有几百M.</p></blockquote><h4 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h4><p>mac下的包管理工具，类似于ubuntu的apt-get<br>brew install nginx ＝ apt-get install nginx</p><h4 id="安装iTem2"><a href="#安装iTem2" class="headerlink" title="安装iTem2"></a>安装iTem2</h4><blockquote><p><strong>坑</strong>：字体乱码<br>安装字体即可：monaco for powerline下载安装完成后在设置中设为该字体即可</p></blockquote><ul><li>hotkey window      //option ＋ space启动</li><li>default           //dock中的快速启动<br>二者均可在<code>profiles/open profies/edit profiles</code>; 设置<code>color，text</code>等等</li></ul><h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p><code>hostname</code>  //查看hostname<br><code>sudo scutil --set HostName MacBook-pro</code>   //修改hostname</p><h4 id="安装开发环境LNMP"><a href="#安装开发环境LNMP" class="headerlink" title="安装开发环境LNMP"></a>安装开发环境LNMP</h4><p>鼓捣了好久，最后还是按照下面这个教程来操作了，从零开始安装Mac下的LNMP环境的过程</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用快捷键&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;delete（backspac）&lt;/li&gt;
&lt;li&gt;fn＋delete（后删）&lt;/li&gt;
&lt;li&gt;option＋v ＝ √&lt;/li&gt;
&lt;li&gt;command ＋ space ＝ spotlight&lt;/li&gt;
&lt;li&gt;option ＋ space ＝ hotkey window 呼起item2&lt;/li&gt;
&lt;li&gt;control ＋ space ＝ 输入法切换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开发配置&quot;&gt;&lt;a href=&quot;#开发配置&quot; class=&quot;headerlink&quot; title=&quot;开发配置&quot;&gt;&lt;/a&gt;开发配置&lt;/h3&gt;&lt;p&gt;查看&lt;strong&gt;Mac开发配置手册&lt;/strong&gt;省了很多时间&lt;br&gt;&lt;a href=&quot;https://aaaaaashu.gitbooks.io/mac-dev-setup/content/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://aaaaaashu.gitbooks.io/mac-dev-setup/content/&lt;/a&gt;&lt;br&gt;iTem2文档也是相当之多&lt;br&gt;&lt;a href=&quot;https://leohxj.gitbooks.io/a-programmer-prepares/content/software/mac/softwares/iTerm2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leohxj.gitbooks.io/a-programmer-prepares/content/software/mac/softwares/iTerm2.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="https://upeng.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Mac" scheme="https://upeng.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>laravel基础任务学习清单</title>
    <link href="https://upeng.github.io/2016/08/15/laravel-basic/"/>
    <id>https://upeng.github.io/2016/08/15/laravel-basic/</id>
    <published>2016-08-15T14:24:32.000Z</published>
    <updated>2022-11-07T03:13:42.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Restful路由"><a href="#关于Restful路由" class="headerlink" title="关于Restful路由"></a>关于Restful路由</h2><p><code>Route::resource(&#39;task&#39;, &#39;TaskController&#39;);</code><br>产生多条路由，<code>POST/DELTE/PUT/GET</code>，对应着<code>TaskController</code>的各个方法；<br>对于laravel5.2，使用 <code>php artisan make:controller TaskController --resource</code>可产生默认的多种方法<br>通过<code>php artisan route:list</code>可以显示已经注册的路由列表</p><p><img src="https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/laravel-route-list.png" alt="laravel-route-list"></p><a id="more"></a><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><blockquote><p>store、update方法常使用</p></blockquote><p>基地控制器<code>Controller</code>内使用了<code>ValidatesRequests</code>这个<code>trait</code>，因此他为所有的控制器都提供了方便的<code>validate</code>验证方法。</p><blockquote><p>调研了解trait机制，为什么TestController use了这个trait，TestController 就可以使用ValidatesRequests的validate方法</p></blockquote><h3 id="最原始的表单验证（Controller中）"><a href="#最原始的表单验证（Controller中）" class="headerlink" title="最原始的表单验证（Controller中）"></a>最原始的表单验证（Controller中）</h3><p>validate方法会验证接受HTTP传入的请求与验证规则，如果验证通过，我们的代码才会继续向下运行。如果验证失败会抛出异常错误返回给用户。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//验证用户请求</span></span><br><span class="line"><span class="keyword">$this</span>-&gt;validate($request,[</span><br><span class="line"><span class="string">'name'</span> =&gt; <span class="string">'required'</span>,</span><br><span class="line"><span class="string">'content'</span> =&gt; <span class="string">'required|min:5'</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过验证，保存至数据库</span></span><br><span class="line">Task::create($request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：我们将验证规则传递到<code>validate</code>方法中，如果验证失败，则自动生成一个对应的响应。并将验证的错误提醒闪存至<code>session</code>，也就是<code>$errors</code>。当验证失败时，用户将被重定向到我们的控制器 <code>create</code>方法，让我们在视图中显示错误的消息：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> (<span class="keyword">count</span>(<span class="variable">$errors</span>) &gt; 0)</span><br><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"alert alert-danger"</span>&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">@<span class="keyword">foreach</span> (<span class="variable">$errors</span>-&gt;all() <span class="keyword">as</span> <span class="variable">$error</span>)</span><br><span class="line">&lt;<span class="keyword">li</span>&gt;&#123;&#123;<span class="variable">$error&#125;</span>&#125;&lt;/<span class="keyword">li</span>&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">@endif</span><br></pre></td></tr></table></figure></p><p><strong>补充</strong>：正常情况下我们想要把错误显示在对应的字段旁边，而不是一起显示在一个列表中；我们打印<code>session</code>中的<code>$errors-&gt;all()</code>是数字索引数组;</p><blockquote><p>要查看特定字段的第一个错误消息【比较常见的场景】</p></blockquote><p><strong>方法如下：</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@if</span> ($errors-&gt;has(<span class="string">'name'</span>))</span><br><span class="line">$errors-&gt;first(<span class="string">'name'</span>);</span><br><span class="line"><span class="variable">@endif</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@if</span> ($error-&gt;has(<span class="string">'content'</span>))</span><br><span class="line">$error-&gt;first(<span class="string">'content'</span>);</span><br><span class="line"><span class="variable">@endif</span></span><br></pre></td></tr></table></figure></p><blockquote><p>我们想要得到一个字段对应的所有error</p></blockquote><p><strong>方法如下</strong>：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($error-&gt;get(<span class="string">'content'</span>) <span class="keyword">as</span> $message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="表单请求验证，自定义请求类"><a href="#表单请求验证，自定义请求类" class="headerlink" title="表单请求验证，自定义请求类"></a>表单请求验证，自定义请求类</h3><blockquote><p>php artisan make request TaskFormReuest;</p></blockquote><p>这时会在<code>Http/Requests</code>目录生成<code>TaskFormReuest.php</code>,修改<code>rules</code>方法，<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//权限判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authorize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rules</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'required|min:5'</span>,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以自定义message方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">messages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'title.required'</span> =&gt; <span class="string">'标题是必填的'</span>,</span><br><span class="line">        <span class="string">'body.required'</span>  =&gt; <span class="string">'消息是必填的'</span>,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//messages还可以这样动态设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">messages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="string">'required'</span> =&gt; <span class="string">':attribute 是必填字段'</span>,</span><br><span class="line"><span class="string">'min'</span>=&gt; <span class="string">':attribute 长度不小于 :min'</span>,</span><br><span class="line">];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="手动创建验证程序"><a href="#手动创建验证程序" class="headerlink" title="手动创建验证程序"></a>手动创建验证程序</h3><p>不使用validatesRequests的validate方法<br>我们可以use Validator类，手动创建一个validator实例，并通过Validator::make()生成一个新的validator</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Validator</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$validator = Validtor::make($request-&gt;all(),[</span><br><span class="line"><span class="string">'name'</span> =&gt; <span class="string">'requeire'</span>,</span><br><span class="line"><span class="string">'content'</span> =&gt; <span class="string">'require|min:6'</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($validator-&gt;fails())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> redirect()-&gt;action(<span class="string">'TaskController@index'</span>)</span><br><span class="line">-&gt;withErrors($validator)</span><br><span class="line">        -&gt;withInput();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>Validator::make($param1, $param2)</code>，其中<code>$param1</code>是验证的数据，<code>$params</code>是规则</p><h2 id="model操作"><a href="#model操作" class="headerlink" title="model操作"></a>model操作</h2><p>增：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Task::create($request);</span><br><span class="line"><span class="number">2.</span> </span><br><span class="line">$task = <span class="keyword">new</span> Task();</span><br><span class="line">$task-&gt;name = $request-&gt;name;</span><br><span class="line">$task-&gt;created_at = Carbon::now();</span><br><span class="line">$task-&gt;save();</span><br></pre></td></tr></table></figure></p><p>删：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">Task</span>::destroy($id);</span><br><span class="line"><span class="number">2.</span><span class="built_in">Task</span>::findOrFail($id)-&gt;<span class="keyword">delete</span>();</span><br></pre></td></tr></table></figure></p><p>改:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task::update(<span class="variable">$request</span>, <span class="variable">$id</span>);</span><br></pre></td></tr></table></figure></p><p>查：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Task::all();</span><br><span class="line"><span class="number">2.</span>Task::where<span class="function"><span class="params">()</span>-&gt;</span>get();</span><br><span class="line"><span class="number">3.</span>Task::orderBy<span class="function"><span class="params">(<span class="string">'created_at'</span>, <span class="string">'desc'</span>)</span>-&gt;</span>get();</span><br></pre></td></tr></table></figure></p><h2 id="factory工厂模型使用"><a href="#factory工厂模型使用" class="headerlink" title="factory工厂模型使用"></a>factory工厂模型使用</h2><ul><li><code>Task Model</code>中设置  <code>protected $fillable = [&#39;name&#39;, &#39;created_at&#39;]</code>;</li><li><p><code>datebase/factories/ModelFactory.php</code>新增</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$factory-&gt;define(App\Task::class, <span class="function"><span class="keyword">function</span> <span class="params">(Faker\Generator $faker)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'name'</span> =&gt; $faker-&gt;sentence,</span><br><span class="line">        <span class="string">'created_at'</span> =&gt; Carbon\Carbon::now(),</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>php artisan tinker</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">namespace App<span class="comment">;</span></span><br><span class="line">factory(<span class="name">App</span>\Task:<span class="symbol">:class</span>,<span class="number">5</span>)-&gt;create()<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于Restful路由&quot;&gt;&lt;a href=&quot;#关于Restful路由&quot; class=&quot;headerlink&quot; title=&quot;关于Restful路由&quot;&gt;&lt;/a&gt;关于Restful路由&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Route::resource(&amp;#39;task&amp;#39;, &amp;#39;TaskController&amp;#39;);&lt;/code&gt;&lt;br&gt;产生多条路由，&lt;code&gt;POST/DELTE/PUT/GET&lt;/code&gt;，对应着&lt;code&gt;TaskController&lt;/code&gt;的各个方法；&lt;br&gt;对于laravel5.2，使用 &lt;code&gt;php artisan make:controller TaskController --resource&lt;/code&gt;可产生默认的多种方法&lt;br&gt;通过&lt;code&gt;php artisan route:list&lt;/code&gt;可以显示已经注册的路由列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/upeng/upeng.github.io/master/image/laravel-route-list.png&quot; alt=&quot;laravel-route-list&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://upeng.github.io/categories/PHP/"/>
    
    
      <category term="laravel" scheme="https://upeng.github.io/tags/laravel/"/>
    
  </entry>
  
</feed>
